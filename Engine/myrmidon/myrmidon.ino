#include <SD.h>

#include <SPI.h>
#include <SSD_13XX.h>

#define __CS  2  //GPIO4 or GPIO2
#define __DC  5   //(D1)

#define DATA_595 10
#define CLOCK_595 16
#define LATCH_595 3

// This was a really cool idea to speed things up, but it seems to cause instability no matter what?
#define X_SKIP 96
#define Y_SKIP 64

#include <PCF8574.h>

inline void __digitalWrite(uint8_t pin, uint8_t val) {
  if(pin < 16){
    if(val) GPOS = (1 << pin);
    else GPOC = (1 << pin);
  } else if(pin == 16){
    if(val) GP16O |= 1;
    else GP16O &= ~1;
  }
}

void sendWord595(uint16_t n) {
  __digitalWrite(DATA_595, (n & 32768) != 0);
  __digitalWrite(CLOCK_595, 1);
  __digitalWrite(CLOCK_595, 0);
  __digitalWrite(DATA_595, (n & 16384) != 0);
  __digitalWrite(CLOCK_595, 1);
  __digitalWrite(CLOCK_595, 0);
  __digitalWrite(DATA_595, (n & 8192) != 0);
  __digitalWrite(CLOCK_595, 1);
  __digitalWrite(CLOCK_595, 0);
  __digitalWrite(DATA_595, (n & 4096) != 0);
  __digitalWrite(CLOCK_595, 1);
  __digitalWrite(CLOCK_595, 0);
  __digitalWrite(DATA_595, (n & 2048) != 0);
  __digitalWrite(CLOCK_595, 1);
  __digitalWrite(CLOCK_595, 0);
  __digitalWrite(DATA_595, (n & 1024) != 0);
  __digitalWrite(CLOCK_595, 1);
  __digitalWrite(CLOCK_595, 0);
  __digitalWrite(DATA_595, (n & 512) != 0);
  __digitalWrite(CLOCK_595, 1);
  __digitalWrite(CLOCK_595, 0);
  __digitalWrite(DATA_595, (n & 256) != 0);
  __digitalWrite(CLOCK_595, 1);
  __digitalWrite(CLOCK_595, 0);

  __digitalWrite(DATA_595, (n & 128) != 0);
  __digitalWrite(CLOCK_595, 1);
  __digitalWrite(CLOCK_595, 0);
  __digitalWrite(DATA_595, (n & 64) != 0);
  __digitalWrite(CLOCK_595, 1);
  __digitalWrite(CLOCK_595, 0);
  __digitalWrite(DATA_595, (n & 32) != 0);
  __digitalWrite(CLOCK_595, 1);
  __digitalWrite(CLOCK_595, 0);
  __digitalWrite(DATA_595, (n & 16) != 0);
  __digitalWrite(CLOCK_595, 1);
  __digitalWrite(CLOCK_595, 0);
  __digitalWrite(DATA_595, (n & 8) != 0);
  __digitalWrite(CLOCK_595, 1);
  __digitalWrite(CLOCK_595, 0);
  __digitalWrite(DATA_595, (n & 4) != 0);
  __digitalWrite(CLOCK_595, 1);
  __digitalWrite(CLOCK_595, 0);
  __digitalWrite(DATA_595, (n & 2) != 0);
  __digitalWrite(CLOCK_595, 1);
  __digitalWrite(CLOCK_595, 0);
  __digitalWrite(DATA_595, (n & 1) != 0);
  __digitalWrite(CLOCK_595, 1);
  __digitalWrite(CLOCK_595, 0);

  __digitalWrite(LATCH_595, 1);
  __digitalWrite(LATCH_595, 0);
}

void sendWord595(uint8_t high, uint8_t low) {
  sendWord595((((uint16_t)high) << 8) | low);
}

// Logo background
const byte logo[6144] PROGMEM = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// SD error image
const byte sd_error[6144] PROGMEM = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// Startup code
const byte startup[4096] PROGMEM = { 0xb1, 0x0, 0x0, 0x18, 0xb2, 0x0, 0x0, 0x0, 0x60, 0x0, 0x0, 0x0, 0x61, 0x1, 0x2, 0x0, 0x52, 0x0, 0x0, 0x0, 0x50, 0x0, 0x0, 0x0, 0x72, 0x0, 0x8b, 0x3, 0x51, 0x0, 0x0, 0x0, 0x50, 0x0, 0x0, 0x0, 0x72, 0x0, 0x90, 0x1, 0x31, 0x5, 0x3, 0x0, 0x41, 0x5, 0x0, 0x18, 0x31, 0x5, 0x2, 0x0, 0x41, 0x5, 0x0, 0x10, 0x40, 0x0, 0x0, 0x0, 0x47, 0x1, 0x0, 0x0 };
// Splash music
const byte splashMusic[4096] PROGMEM = { 0x0, 0x4, 0x0, 0x0, 0x1, 0x48, 0x0, 0x15, 0x10, 0x0, 0x10, 0x51, 0x0, 0x40, 0x31, 0x6, 0x10, 0x80, 0x6, 0x10, 0x4d, 0x6, 0x10, 0x80, 0x6, 0x10, 0x51, 0x6, 0x10, 0x80, 0x6, 0x10, 0x53, 0x0, 0x40, 0x33, 0x6, 0x10, 0x80, 0x6, 0x10, 0x4f, 0x6, 0x10, 0x80, 0x6, 0x10, 0x53, 0x6, 0x10, 0x80, 0x6, 0x10, 0x55, 0x0, 0x40, 0x34, 0x6, 0x10, 0x80, 0x1e, 0x20, 0x45, 0x6, 0x20, 0x40, 0x6, 0x20, 0x3d, 0x6, 0x20, 0x39, 0x0, 0x40, 0x80, 0x0c, 0x20, 0x80, 0x6, 0x0, 0x0, 0x90, 0x7, 0x0};

PCF8574 pcf8574(0x20, 4, (uint8_t)0);

/*
 SCLK:D5
 MOSI:D7
*/


SSD_13XX tft = SSD_13XX(__CS, __DC);

uint8_t framebuffer[64][96];
uint8_t flagbuffer[64][48];
uint32_t checksums[64/Y_SKIP][96/X_SKIP];
uint8_t background[64][96];
uint8_t spritesheets[2][64][48];
uint32_t palette[256];
uint8_t palette_offset;
uint8_t test_flags;

uint16_t memory[8192];
uint16_t routines[256];
uint16_t stack[32];
uint8_t stack_size;

uint16_t window_pointer;

uint16_t instruction_pointer;
bool has_jumped;

bool input_state[8];
bool input_state_prev[8];
uint32_t input_poll_time;

void startAY() {
  sendWord595(2, 0);
  delay(10);
}

uint16_t registers[16] = {0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff};

void setRegister(uint8_t address, uint8_t value) {
  if (registers[address] == value)
    return;
  registers[address] = value;
  sendWord595(2, address);
  delayMicroseconds(5);
  sendWord595(7, address);
  delayMicroseconds(5);
  sendWord595(2, address);
  delayMicroseconds(5);
  sendWord595(2, value);
  delayMicroseconds(5);
  sendWord595(6, value);
  delayMicroseconds(5);
  sendWord595(2, value);
  delayMicroseconds(5);
}

// Credits to AlanFromJapan for this array
int midiToPeriod[] = {//MIDI note number
  15289, 14431, 13621, 12856, 12135, 11454, 10811, 10204,//0-7
  9631, 9091, 8581, 8099, 7645, 7215, 6810, 6428,//8-15
  6067, 5727, 5405, 5102, 4816, 4545, 4290, 4050,//16-23
  3822, 3608, 3405, 3214, 3034, 2863, 2703, 2551,//24-31
  2408, 2273, 2145, 2025, 1911, 1804, 1703, 1607,//32-39
  1517, 1432, 1351, 1276, 1204, 1136, 1073, 1012,//40-47
  956, 902, 851, 804, 758, 716, 676, 638,//48-55
  602, 568, 536, 506, 478, 451, 426, 402,//56-63
  379, 358, 338, 319, 301, 284, 268, 253,//64-71
  239, 225, 213, 201, 190, 179, 169, 159,//72-79
  150, 142, 134, 127, 119, 113, 106, 100,//80-87
  95, 89, 84, 80, 75, 71, 67, 63,//88-95
  60, 56, 53, 50, 47, 45, 42, 40,//96-103
  38, 36, 34, 32, 30, 28, 27, 25,//104-111
  24, 22, 21, 20, 19, 18, 17, 16,//112-119
  15, 14, 13, 13, 12, 11, 11, 10,//120-127
  0//off
};

uint32_t nextTickMicros[2] = {0, 0};

uint8_t *patterns[64];

struct Playhead {
  uint8_t* instructionPointer = (uint8_t*)memory;
  bool playheadEnabled = false;
  uint8_t tickTime = 1;
  uint16_t ticksToNext = 0;
  uint8_t* patternStack[8];
  uint8_t patternStackSize = 0;

  uint16_t startPeriod[3][4] = { {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} };
  uint16_t targetPeriod[3][4] = { {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} };
  uint8_t chordSize[3] = { 1, 1, 1 };
  uint8_t chordLength[3] = { 1, 1, 1 };
  uint8_t chordTicks[3] = { 0, 0, 0 };
  uint8_t pitchTicks[3] = { 0, 0, 0 };
  uint8_t volumeMode[3] = { 3, 3, 3 }; // 0 = attack, 1 = decay, 2 = sustain, 3 = release
  uint8_t volumeTicks[3] = { 0, 0, 0 };
  uint8_t maxAmplitude[3] = { 127, 127, 127 };
  uint8_t attack[3] = { 0, 0, 0 };
  uint8_t decay[3] = { 0, 0, 0 };
  uint8_t sustain[3] = { 255, 255, 255 };
  uint8_t release[3] = { 0, 0, 0 };
  uint8_t pitchSlide[3] = { 0, 0, 0 };

  uint16_t startPeriodBass[4] = { 0, 0, 0, 0 };
  uint16_t targetPeriodBass[4] = { 0, 0, 0, 0 };
  uint8_t chordSizeBass = 1;
  uint8_t chordLengthBass = 1;
  uint8_t chordTicksBass = 0;
  uint8_t pitchTicksBass = 0;
  uint8_t bassRunning = 0;
  uint8_t pitchSlideBass = 0;
  uint8_t bassWaveform = 10;

  uint8_t drumTimer = 255;
  uint8_t drumType = 0; // 0 = kick, 1 = snare, 2 = closed hat, 3 = half hat, 4 = open hat, 5 = crash

  uint16_t period[3];
  uint16_t bassPeriod;
  uint8_t amplitude[3];
  uint8_t noisePeriod;
  uint8_t mixer;
};

Playhead p[2];
uint8_t prevBassWaveform = 0;
  
void combineSignals() {
  if (p[1].amplitude[0] > 0) {
    setRegister(0, p[1].period[0]);
    setRegister(1, p[1].period[0] >> 8);
    setRegister(8, p[1].amplitude[0]);
  }
  else {
    setRegister(0, p[0].period[0]);
    setRegister(1, p[0].period[0] >> 8);
    setRegister(8, p[0].amplitude[0]);
  }

  if (p[1].amplitude[1] > 0) {
    setRegister(2, p[1].period[1]);
    setRegister(3, p[1].period[1] >> 8);
    setRegister(9, p[1].amplitude[1]);
  }
  else {
    setRegister(2, p[0].period[1]);
    setRegister(3, p[0].period[1] >> 8);
    setRegister(9, p[0].amplitude[1]);
  }

  if (p[1].amplitude[2] > 0) {
    setRegister(4, p[1].period[2]);
    setRegister(5, p[1].period[2] >> 8);
    setRegister(10, p[1].amplitude[2]);
  }
  else {
    setRegister(4, p[0].period[2]);
    setRegister(5, p[0].period[2] >> 8);
    setRegister(10, p[0].amplitude[2]);
  }

  if (p[1].mixer != 0b11111000)
    setRegister(7, p[1].mixer);
  else
    setRegister(7, p[0].mixer);

  if (p[1].mixer & 0b00000100 != 0) {
    setRegister(11, p[1].bassPeriod);
    setRegister(12, p[1].bassPeriod >> 8);
    if (p[1].bassWaveform != prevBassWaveform) {
      setRegister(13, p[1].bassWaveform);
      prevBassWaveform = p[1].bassWaveform;
    }
  }
  else {
    setRegister(11, p[0].bassPeriod);
    setRegister(12, p[0].bassPeriod >> 8);
    if (p[0].bassWaveform != prevBassWaveform) {
      setRegister(13, p[0].bassWaveform);
      prevBassWaveform = p[0].bassWaveform;
    }
  }

  if (p[1].mixer & 0b00111000 != 0b00111000)
    setRegister(6, p[1].noisePeriod);
  else
    setRegister(6, p[0].noisePeriod);
}

uint32_t psMillis = 0;

void processSound() {
  if (millis() == psMillis)
    return;
  psMillis = millis();
  ESP.wdtFeed(); // Tell the watchdog timer that we're okay!
  for (int d = 0; d < 2; d++) {
    if (!p[d].playheadEnabled)
      continue;
    uint32_t currentMicros = micros();
    // Serial.println("PROCESSSOUND CALLED");
    while ((int32_t)(currentMicros - nextTickMicros[d]) > 0) {
      // Serial.println((int32_t)(currentMicros - nextTickMicros[d]));
      nextTickMicros[d] += (uint32_t)(p[d].tickTime) * 100;
      while (p[d].ticksToNext == 0) {
        // Serial.println("PROCESSING SOUND INSTRUCTION");

        /*Serial.print(d);
        Serial.print(" ");
        Serial.print(*(p[d].instructionPointer));
        Serial.print(" ");
        Serial.print(*(p[d].instructionPointer + 1));
        Serial.print(" ");
        Serial.println(*(p[d].instructionPointer + 2));*/

        // Process this instruction!
        // printf("%d: %d %d %d\n", d, *(p[d].instructionPointer), *(p[d].instructionPointer + 1), *(p[d].instructionPointer + 2));
        switch (*(p[d].instructionPointer + 1)) {
        case 0x00:
          p[d].playheadEnabled = false;
          break;
        case 0x01:
          p[d].tickTime = *(p[d].instructionPointer + 2);
          if (p[d].tickTime == 0)
            p[d].tickTime = 1;
          break;
        case 0x02:
          break;
        case 0x03:
          p[d].ticksToNext = 256 * (uint16_t)(*(p[d].instructionPointer + 2));
          break;
        case 0x04:
          break;
        case 0x05:
          if (p[d].patternStackSize == 0) {
            p[d].playheadEnabled = false;
            break;
          }
          p[d].patternStackSize--;
          p[d].instructionPointer = p[d].patternStack[p[d].patternStackSize];
          break;
        case 0x06:
          p[d].patternStack[p[d].patternStackSize] = p[d].instructionPointer;
          p[d].patternStackSize++;
          p[d].instructionPointer = patterns[*(p[d].instructionPointer + 2)];
          break;
        case 0x07:
          p[d].instructionPointer = patterns[*(p[d].instructionPointer + 2)];
          break;
        case 0x10:
          if (*(p[d].instructionPointer + 2) == 128) {
            p[d].volumeMode[0] = 3;
            p[d].volumeTicks[0] = 0;
          }
          else {
            p[d].startPeriod[0][0] = midiToPeriod[*(p[d].instructionPointer + 2)];
            p[d].targetPeriod[0][0] = midiToPeriod[*(p[d].instructionPointer + 2)];
            p[d].pitchTicks[0] = 0;
            p[d].volumeMode[0] = 0;
            p[d].volumeTicks[0] = 0;
            p[d].chordSize[0] = 1;
          }
          break;
        case 0x11:
          p[d].maxAmplitude[0] = *(p[d].instructionPointer + 2);
          break;
        case 0x12:
          p[d].attack[0] = *(p[d].instructionPointer + 2);
          break;
        case 0x13:
          p[d].decay[0] = *(p[d].instructionPointer + 2);
          break;
        case 0x14:
          p[d].sustain[0] = *(p[d].instructionPointer + 2);
          break;
        case 0x15:
          p[d].release[0] = *(p[d].instructionPointer + 2);
          break;
        case 0x16:
          p[d].pitchSlide[0] = *(p[d].instructionPointer + 2);
          break;
        case 0x17:
          p[d].targetPeriod[0][p[d].chordSize[0]] = midiToPeriod[*(p[d].instructionPointer + 2)];
          if (p[d].volumeMode[0] == 0 && p[d].volumeTicks[0] == 0)
            p[d].startPeriod[0][p[d].chordSize[0]] = midiToPeriod[*(p[d].instructionPointer + 2)];
          p[d].chordSize[0]++;
          break;
        case 0x18:
          p[d].chordLength[0] = *(p[d].instructionPointer + 2);
          if (p[d].chordLength[0] == 0)
            p[d].chordLength[0] = 1;
          break;
        case 0x1a:
          if (*(p[d].instructionPointer + 2) == 128) {
            p[d].volumeMode[0] = 3;
            p[d].volumeTicks[0] = 0;
          }
          else {
            if (p[d].volumeMode[0] == 3) {
              p[d].startPeriod[0][0] = midiToPeriod[*(p[d].instructionPointer + 2)];
              p[d].targetPeriod[0][0] = midiToPeriod[*(p[d].instructionPointer + 2)];
              p[d].pitchTicks[0] = 0;
              p[d].volumeMode[0] = 0;
              p[d].volumeTicks[0] = 0;
              p[d].chordSize[0] = 1;
            }
            else {
              for (int i = 0; i < 4; i++)
                p[d].startPeriod[0][i] = p[d].targetPeriod[0][i];
              p[d].targetPeriod[0][0] = midiToPeriod[*(p[d].instructionPointer + 2)];
              p[d].pitchTicks[0] = 0;
              p[d].chordSize[0] = 1;
            }
          }
          break;
        case 0x20:
          if (*(p[d].instructionPointer + 2) == 128) {
            p[d].volumeMode[1] = 3;
            p[d].volumeTicks[1] = 0;
          }
          else {
            p[d].startPeriod[1][0] = midiToPeriod[*(p[d].instructionPointer + 2)];
            p[d].targetPeriod[1][0] = midiToPeriod[*(p[d].instructionPointer + 2)];
            p[d].pitchTicks[1] = 0;
            p[d].volumeMode[1] = 0;
            p[d].volumeTicks[1] = 0;
            p[d].chordSize[1] = 1;
          }
          break;
        case 0x21:
          p[d].maxAmplitude[1] = *(p[d].instructionPointer + 2);
          break;
        case 0x22:
          p[d].attack[1] = *(p[d].instructionPointer + 2);
          break;
        case 0x23:
          p[d].decay[1] = *(p[d].instructionPointer + 2);
          break;
        case 0x24:
          p[d].sustain[1] = *(p[d].instructionPointer + 2);
          break;
        case 0x25:
          p[d].release[1] = *(p[d].instructionPointer + 2);
          break;
        case 0x26:
          p[d].pitchSlide[1] = *(p[d].instructionPointer + 2);
          break;
        case 0x27:
          p[d].targetPeriod[1][p[d].chordSize[1]] = midiToPeriod[*(p[d].instructionPointer + 2)];
          if (p[d].volumeMode[1] == 0 && p[d].volumeTicks[1] == 0)
            p[d].startPeriod[1][p[d].chordSize[1]] = midiToPeriod[*(p[d].instructionPointer + 2)];
          p[d].chordSize[1]++;
          break;
        case 0x28:
          p[d].chordLength[1] = *(p[d].instructionPointer + 2);
          if (p[d].chordLength[1] == 0)
            p[d].chordLength[1] = 1;
          break;
        case 0x2a:
          if (*(p[d].instructionPointer + 2) == 128) {
            p[d].volumeMode[1] = 3;
            p[d].volumeTicks[1] = 0;
          }
          else {
            if (p[d].volumeMode[1] == 3) {
              p[d].startPeriod[1][0] = midiToPeriod[*(p[d].instructionPointer + 2)];
              p[d].targetPeriod[1][0] = midiToPeriod[*(p[d].instructionPointer + 2)];
              p[d].pitchTicks[1] = 0;
              p[d].volumeMode[1] = 0;
              p[d].volumeTicks[1] = 0;
              p[d].chordSize[1] = 1;
            }
            else {
              for (int i = 0; i < 4; i++)
                p[d].startPeriod[1][i] = p[d].targetPeriod[1][i];
              p[d].targetPeriod[1][0] = midiToPeriod[*(p[d].instructionPointer + 2)];
              p[d].pitchTicks[1] = 0;
              p[d].chordSize[1] = 1;
            }
          }
          break;
        case 0x30:
          if (*(p[d].instructionPointer + 2) == 128) {
            p[d].volumeMode[2] = 3;
            p[d].volumeTicks[2] = 0;
          }
          else {
            p[d].startPeriod[2][0] = midiToPeriod[*(p[d].instructionPointer + 2)];
            p[d].targetPeriod[2][0] = midiToPeriod[*(p[d].instructionPointer + 2)];
            p[d].pitchTicks[2] = 0;
            p[d].volumeMode[2] = 0;
            p[d].volumeTicks[2] = 0;
            p[d].chordSize[2] = 1;
          }
          break;
        case 0x31:
          p[d].maxAmplitude[2] = *(p[d].instructionPointer + 2);
          break;
        case 0x32:
          p[d].attack[2] = *(p[d].instructionPointer + 2);
          break;
        case 0x33:
          p[d].decay[2] = *(p[d].instructionPointer + 2);
          break;
        case 0x34:
          p[d].sustain[2] = *(p[d].instructionPointer + 2);
          break;
        case 0x35:
          p[d].release[2] = *(p[d].instructionPointer + 2);
          break;
        case 0x36:
          p[d].pitchSlide[2] = *(p[d].instructionPointer + 2);
          break;
        case 0x37:
          p[d].targetPeriod[2][p[d].chordSize[2]] = midiToPeriod[*(p[d].instructionPointer + 2)];
          if (p[d].volumeMode[2] == 0 && p[d].volumeTicks[2] == 0)
            p[d].startPeriod[2][p[d].chordSize[2]] = midiToPeriod[*(p[d].instructionPointer + 2)];
          p[d].chordSize[2]++;
          break;
        case 0x38:
          p[d].chordLength[2] = *(p[d].instructionPointer + 2);
          if (p[d].chordLength[2] == 0)
            p[d].chordLength[2] = 1;
          break;
        case 0x3a:
          if (*(p[d].instructionPointer + 2) == 128) {
            p[d].volumeMode[2] = 3;
            p[d].volumeTicks[2] = 0;
          }
          else {
            if (p[d].volumeMode[2] == 3) {
              p[d].startPeriod[2][0] = midiToPeriod[*(p[d].instructionPointer + 2)];
              p[d].targetPeriod[2][0] = midiToPeriod[*(p[d].instructionPointer + 2)];
              p[d].pitchTicks[2] = 0;
              p[d].volumeMode[2] = 0;
              p[d].volumeTicks[2] = 0;
              p[d].chordSize[2] = 1;
            }
            else {
              for (int i = 0; i < 4; i++)
                p[d].startPeriod[2][i] = p[d].targetPeriod[2][i];
              p[d].targetPeriod[2][0] = midiToPeriod[*(p[d].instructionPointer + 2)];
              p[d].pitchTicks[2] = 0;
              p[d].chordSize[2] = 1;
            }
          }
          break;
        case 0x40:
          if (*(p[d].instructionPointer + 2) == 128) {
            p[d].bassRunning = 0;
          }
          else {
            p[d].startPeriodBass[0] = midiToPeriod[*(p[d].instructionPointer + 2) + 60];
            p[d].targetPeriodBass[0] = midiToPeriod[*(p[d].instructionPointer + 2) + 60];
            p[d].bassRunning = 1;
            p[d].pitchTicksBass = 0;
            p[d].chordSizeBass = 1;
          }
          break;
        case 0x46:
          p[d].pitchSlideBass = *(p[d].instructionPointer + 2);
          break;
        case 0x47:
          p[d].targetPeriodBass[p[d].chordSizeBass] = midiToPeriod[*(p[d].instructionPointer + 2) + 60];
          if (p[d].pitchTicksBass == 0 && p[d].startPeriodBass[0] == p[d].targetPeriodBass[0])
            p[d].startPeriodBass[p[d].chordSizeBass] = midiToPeriod[*(p[d].instructionPointer + 2) + 60];
          p[d].chordSizeBass++;
          break;
        case 0x48:
          p[d].chordLengthBass = *(p[d].instructionPointer + 2);
          if (p[d].chordLengthBass == 0)
            p[d].chordLengthBass = 1;
          break;
        case 0x49:
          if (*(p[d].instructionPointer + 2))
            p[d].bassWaveform = 12;
          else
            p[d].bassWaveform = 10;
        case 0x4a:
          if (*(p[d].instructionPointer + 2) == 128) {
            p[d].bassRunning = 0;
          }
          else {
            if (!p[d].bassRunning) {
              p[d].startPeriodBass[0] = midiToPeriod[*(p[d].instructionPointer + 2) + 60];
              p[d].targetPeriodBass[0] = midiToPeriod[*(p[d].instructionPointer + 2) + 60];
              p[d].bassRunning = 1;
              p[d].pitchTicksBass = 0;
              p[d].chordSizeBass = 1;
            }
            else {
              for (int i = 0; i < 4; i++)
                p[d].startPeriodBass[i] = p[d].targetPeriodBass[i];
              p[d].targetPeriodBass[0] = midiToPeriod[*(p[d].instructionPointer + 2) + 60];
              p[d].pitchTicksBass = 0;
              p[d].chordSizeBass = 1;
            }
          }
          break;
        case 0x50:
          p[d].drumType = *(p[d].instructionPointer + 2);
          p[d].drumTimer = 0;
        }
        p[d].instructionPointer += 3;
        p[d].ticksToNext += *p[d].instructionPointer;
        if (!p[d].playheadEnabled)
          break;
      }
      p[d].ticksToNext--;
      if (p[d].playheadEnabled) {
        uint32_t micr = micros();
        for (int i = 0; i < 3; i++) {
          // Which note in the chord is this?
          uint8_t chordIndex;
          if (p[d].chordTicks[i] >= p[d].chordLength[i] * p[d].chordSize[i])
            p[d].chordTicks[i] = 0;
          chordIndex = p[d].chordTicks[i] / p[d].chordLength[i];
          p[d].chordTicks[i]++;

          // What's the pitch of the oscillator?
          uint16_t period;
          if (p[d].pitchSlide[i] == 0)
            period = p[d].targetPeriod[i][chordIndex];
          else
            period = (p[d].startPeriod[i][chordIndex] * (p[d].pitchSlide[i] - p[d].pitchTicks[i]) + p[d].targetPeriod[i][chordIndex] * p[d].pitchTicks[i]) / p[d].pitchSlide[i];
          if (p[d].pitchTicks[i] < p[d].pitchSlide[i])
            p[d].pitchTicks[i]++;
          p[d].period[i] = period;
          // What's the volume?
          uint8_t volume;
          switch (p[d].volumeMode[i]) {
          case 0:
            if (p[d].attack[i] == 0)
              volume = p[d].maxAmplitude[i];
            else
              volume = (uint16_t)p[d].maxAmplitude[i] * p[d].volumeTicks[i] / p[d].attack[i];
            if (p[d].volumeTicks[i] < p[d].attack[i])
              p[d].volumeTicks[i]++;
            if (p[d].volumeTicks[i] >= p[d].attack[i]) {
              p[d].volumeTicks[i] = 0;
              p[d].volumeMode[i] = 1;
            }
            break;
          case 1:
            if (p[d].decay[i] == 0)
              volume = (uint16_t)p[d].maxAmplitude[i] * p[d].sustain[i] / 255;
            else
              volume = ((uint16_t)p[d].maxAmplitude[i] * (p[d].decay[i] - p[d].volumeTicks[i]) + ((uint16_t)p[d].maxAmplitude[i] * p[d].sustain[i] / 255) * p[d].volumeTicks[i]) / p[d].decay[i];
            if (p[d].volumeTicks[i] < p[d].decay[i])
              p[d].volumeTicks[i]++;
            if (p[d].volumeTicks[i] >= p[d].decay[i]) {
              p[d].volumeTicks[i] = 0;
              p[d].volumeMode[i] = 2;
            }
            break;
          case 2:
            volume = (uint16_t)p[d].maxAmplitude[i] * p[d].sustain[i] / 255;
            p[d].volumeTicks[i] = 0;
            break;
          default:
            if (p[d].release[i] == 0)
              volume = 0;
            else
              volume = ((uint16_t)p[d].maxAmplitude[i] * p[d].sustain[i] / 255) * (p[d].release[i] - p[d].volumeTicks[i]) / p[d].release[i];
            if (p[d].volumeTicks[i] < p[d].release[i])
              p[d].volumeTicks[i]++;
            break;
          }

          p[d].amplitude[i] = volume >> 4;
        }

        // Do all that stuff for bass!
        // Which note in the chord is this?
        uint8_t chordIndex;
        if (p[d].chordTicksBass >= p[d].chordLengthBass * p[d].chordSizeBass)
          p[d].chordTicksBass = 0;
        chordIndex = p[d].chordTicksBass / p[d].chordLengthBass;
        p[d].chordTicksBass++;

        // What's the pitch of the oscillator?
        uint16_t period;
        if (p[d].pitchSlideBass == 0)
          period = p[d].targetPeriodBass[chordIndex];
        else
          period = (p[d].startPeriodBass[chordIndex] * (p[d].pitchSlideBass - p[d].pitchTicksBass) + p[d].targetPeriodBass[chordIndex] * p[d].pitchTicksBass) / p[d].pitchSlideBass;
        if (p[d].pitchTicksBass < p[d].pitchSlideBass)
          p[d].pitchTicksBass++;
        p[d].bassPeriod = period;

        if (p[d].bassRunning) {
          p[d].amplitude[2] = 16;
        }

        if (p[d].bassRunning)
          p[d].mixer = 0b11111100;
        else
          p[d].mixer = 0b11111000;

        // Drums?
        if (p[d].drumTimer < 255) {
          switch (p[d].drumType) {
          case 0:
            if (p[d].drumTimer == 0) {
              p[d].mixer = 0b11111000;
              p[d].period[2] = 1024;
              p[d].amplitude[2] = 15;
            }
            else if (p[d].drumTimer == 1) {
              p[d].mixer = 0b11111000;
              p[d].period[2] = 1536;
              p[d].amplitude[2] = 15;
            }
            else if (p[d].drumTimer == 2) {
              p[d].mixer = 0b11111000;
              p[d].period[2] = 2048;
              p[d].amplitude[2] = 15;
            }
            else if (p[d].drumTimer == 3) {
              p[d].mixer = 0b11111000;
              p[d].period[2] = 2560;
              p[d].amplitude[2] = 15;
            }
            break;
          case 1:
            if (p[d].drumTimer < 4) {
              p[d].mixer = 0b11011100;
              p[d].noisePeriod = 31;
              p[d].amplitude[2] = 15 - p[d].drumTimer * 4;
            }
            break;
          case 2:
            if (p[d].drumTimer < 2) {
              p[d].mixer = 0b11011100;
              p[d].noisePeriod = 3;
              p[d].amplitude[2] = 15 - p[d].drumTimer * 8;
            }
            break;
          case 3:
            if (p[d].drumTimer < 8) {
              p[d].mixer = 0b11011100;
              p[d].noisePeriod = 3;
              p[d].amplitude[2] = 15 - p[d].drumTimer * 2;
            }
            break;
          case 4:
            if (p[d].drumTimer < 128) {
              p[d].mixer = 0b11011100;
              p[d].noisePeriod = 3;
              p[d].amplitude[2] = 15 - p[d].drumTimer / 8;
            }
            break;
          case 5:
            if (p[d].drumTimer < 128) {
              p[d].mixer = 0b11011100;
              p[d].noisePeriod = 15;
              p[d].amplitude[2] = 15 - p[d].drumTimer / 8;
            }
            break;
          }

          p[d].drumTimer++;
        }


      }
      else {
        p[d].mixer = 0b11111000;
        p[d].amplitude[0] = 0;
        p[d].amplitude[1] = 0;
        p[d].amplitude[2] = 0;
      }
      
      combineSignals();
    }
  }
}

void readPage(uint16_t page_index, uint16_t page_address) {
  if (page_address >= 8192 || (page_address & 0x07ff) != 0)
    return;
  String indexStr = String(page_index, HEX);
  while (indexStr.length() < 4)
    indexStr = "0" + indexStr;
  String fname = indexStr + "R.bin";
  if (SD.exists(fname.c_str())) {
    File file = SD.open(fname.c_str());
    file.read((uint8_t*)memory + 2 * page_address, 4096);
    file.close();
  }
  else {
    fname = indexStr + "W.bin";
    if (SD.exists(fname.c_str())) {
      File file = SD.open(fname.c_str());
      file.read((uint8_t*)memory + 2 * page_address, 4096);
      file.close();
    }
  }
}

void writePage(uint16_t page_index, uint16_t page_address) {
  if (page_address >= 8192 || (page_address & 0x07ff) != 0)
    return;
  String indexStr = String(page_index, HEX);
  while (indexStr.length() < 4)
    indexStr = "0" + indexStr;
  String fname = indexStr + "W.bin";
  if (SD.exists(fname.c_str())) {
    File file = SD.open(fname.c_str(), FILE_WRITE);
    file.seek(0);
    file.write((uint8_t*)memory + 2 * page_address, 4096);
    file.close();
  }
}

bool sdCardValid = true;

void setup() {
  Serial.begin(115200);
  if (!SD.begin(D8)) {
    Serial.println("SD ERROR");
    sdCardValid = false;
  }
  else
    Serial.println("SD SUCCESS");

  tft.begin();
  tft.setBackground(0);
  tft.setRotation(0);

  pcf8574.pinMode(P0, INPUT);
  pcf8574.pinMode(P1, INPUT);
  pcf8574.pinMode(P2, INPUT);
  pcf8574.pinMode(P3, INPUT);
  pcf8574.pinMode(P4, INPUT);
  pcf8574.pinMode(P5, INPUT);
  pcf8574.pinMode(P6, INPUT);
  pcf8574.pinMode(P7, INPUT);
  pcf8574.begin();

  pinMode(DATA_595, OUTPUT);
  pinMode(CLOCK_595, OUTPUT);
  pinMode(LATCH_595, OUTPUT);

  startAY();

  for (int y = 0; y < 64; y++) {
    for (int x = 0; x < 96; x++) {
      framebuffer[y][x] = 0;
      if (x < 48)
        flagbuffer[y][x] = 0;
      background[y][x] = 0;
      spritesheets[x%2][y][x/2] = 0;
    }
  }

  for (int i = 0; i < 8192; i++) {
    memory[i] = 0;
  }
  for (int i = 0; i < 256; i++) {
    routines[i] = 0;
  }
  for (int i = 0; i < 32; i++) {
    stack[i] = 0;
  }

  for (int i = 0; i < 256; i++) {
    palette[i] = 0;
  }
  palette_offset = 0;

  test_flags = 0;

  memcpy_P((byte*)(memory)+4096, startup, 4096);
  memcpy_P((byte*)(memory)+4096*3, splashMusic, 4096);

  memcpy_P(background, logo, 6144);
  
  memory[1] = 1;
  memory[2] = 0xffff;
  window_pointer = 0x0080;
  instruction_pointer = 0x0800;

  for (int i = 0; i < 8; i++) {
    input_state[i] = 0;
    input_state_prev[i] = 0;
  }

  input_poll_time = millis();
  nextTickMicros[0] = micros();
  nextTickMicros[1] = micros();

  Serial.println("INITIALIZED");
}

inline uint16_t getR(uint8_t reg) {
  if (reg < 0x80)
    return memory[reg];
  else
    return memory[(uint16_t)(reg - 0x80) + window_pointer];
}

inline void setR(uint8_t reg, uint16_t value) {
  uint16_t address;
  if (reg < 0x80)
    address = reg;
  else
    address = (uint16_t)(reg - 0x80) + window_pointer;
  if (address <= 0x0002)
    return;
  memory[address] = value;
}

uint32_t DEBUG_UINT32;

int counter = 0;

void loop(void) {
  // Poll input if necessary
  if (millis() >= input_poll_time) {
    input_poll_time = millis() + 25;
    for (int i = 0; i < 8; i++) {
      input_state_prev[i] = input_state[i];
    }
    PCF8574::DigitalInput di = pcf8574.digitalReadAll();
    input_state[0] = di.p0;
    input_state[1] = di.p1;
    input_state[2] = di.p2;
    input_state[3] = di.p3;
    input_state[4] = di.p4;
    input_state[5] = di.p5;
    input_state[6] = di.p6;
    input_state[7] = di.p7;
  }

  // Process sound to make sure that keeps going smoothly
  processSound();

  // Read the four bytes at IP
  uint16_t inst1, inst2;
  inst1 = memory[instruction_pointer];
  inst2 = memory[instruction_pointer+1];
  // Determine opcode and register indices
  uint8_t opcode, registerX, registerY, registerZ;
  opcode = inst1;
  registerX = inst1 >> 8;
  registerY = inst2;
  registerZ = inst2 >> 8;

  // Serial.print("PROCESSING MAIN INSTRUCTION ");
  // Serial.println(opcode);
  
  /*{
      String valStr;
      valStr = String(instruction_pointer, HEX);
      Serial.print(valStr.c_str());
      Serial.print(": ");
      valStr = String(opcode, HEX);
      Serial.print(valStr.c_str());
      Serial.print(" ");
      valStr = String(registerX, HEX);
      Serial.print(valStr.c_str());
      Serial.print(" ");
      valStr = String(registerY, HEX);
      Serial.print(valStr.c_str());
      Serial.print(" ");
      valStr = String(registerZ, HEX);
      Serial.print(valStr.c_str());
      Serial.println(" ");
      delay(1000);
    }*/

  bool had_jumped = has_jumped;
  has_jumped = false;
  
  switch (opcode) {
  case 0x00:
    // nop
    break;
  case 0x01:
    // end
    instruction_pointer += 2 * inst2;
    has_jumped = inst2 != 0;
    break;
  case 0x02:
    // if
    if (getR(registerX) == 0) {
      instruction_pointer += 2 * inst2;
      has_jumped = inst2 != 0;
    }
    break;
  case 0x03:
    // while
    /*{
      String valStr;
      valStr = String(instruction_pointer, HEX);
      Serial.print(valStr.c_str());
      Serial.print(": ");
      if (getR(registerX) == 0) {
        Serial.println("PASS");
      }
      else {
        Serial.println("LOOP");
      }
      delay(100);
    }*/
    if (getR(registerX) == 0) {
      instruction_pointer += 2 * inst2;
      has_jumped = inst2 != 0;
    }
    break;
  case 0x04:
    // else
    if (!had_jumped) {
      instruction_pointer += 2 * inst2;
      has_jumped = inst2 != 0;
    }
    break;
  case 0x05:
    // switch
    {
      uint16_t val = getR(registerX);
      instruction_pointer += 2 * val;
      has_jumped = val != 0;
    }
    break;
  case 0x06:
    // gz
    if (getR(registerX) == 0) {
      instruction_pointer += 2 * inst2;
      has_jumped = inst2 != 0;
    }
    break;
  case 0x07:
    // gnz
    if (getR(registerX) != 0) {
      instruction_pointer += 2 * inst2;
      has_jumped = inst2 != 0;
    }
    break;
  case 0x08:
    // def
    routines[registerX] = instruction_pointer + 2;
    instruction_pointer += 2 * inst2;
    has_jumped = inst2 != 0;
    break;
  case 0x09:
    // call
    stack[stack_size] = instruction_pointer + 2;
    stack_size++;
    instruction_pointer = routines[registerX];
    has_jumped = true;
    break;
  case 0x0a:
    // goto
    instruction_pointer = inst2;
    has_jumped = true;
    break;
  case 0x0b:
    // break
    instruction_pointer += 2 * inst2;
    has_jumped = inst2 != 0;
    break;
  case 0x0c:
    // continue
    instruction_pointer += 2 * inst2;
    has_jumped = inst2 != 0;
    break;
  case 0x0d:
    // return
    stack_size--;
    instruction_pointer = stack[stack_size];
    has_jumped = true;
    break;
  case 0x0e:
    // reset
    ESP.restart();
    break;
  case 0x0f:
    // DEBUG OPCODE
    {
      uint16_t val = getR(registerX);
      String valStr = String(val);
      Serial.println(valStr.c_str());
    }
    break;
  case 0x10:
    // +
    {
      uint16_t valY = getR(registerY);
      uint16_t valZ = getR(registerZ);
      setR(registerX, valY + valZ);
    }
    break;
  case 0x11:
    // -
    {
      uint16_t valY = getR(registerY);
      uint16_t valZ = getR(registerZ);
      setR(registerX, valY - valZ);
    }
    break;
  case 0x12:
    // *
    {
      uint16_t valY = getR(registerY);
      uint16_t valZ = getR(registerZ);
      setR(registerX, valY * valZ);
    }
    break;
  case 0x13:
    // /
    {
      uint16_t valY = getR(registerY);
      uint16_t valZ = getR(registerZ);
      setR(registerX, valY / valZ);
    }
    break;
  case 0x14:
    // s/
    {
      uint16_t valY = getR(registerY);
      uint16_t valZ = getR(registerZ);
      setR(registerX, (uint16_t)(((int16_t)valY) / ((int16_t)valZ)));
    }
    break;
  case 0x15:
    // %
    {
      uint16_t valY = getR(registerY);
      uint16_t valZ = getR(registerZ);
      setR(registerX, valY % valZ);
    }
    break;
  case 0x16:
    // s%
    {
      uint16_t valY = getR(registerY);
      uint16_t valZ = getR(registerZ);
      setR(registerX, (uint16_t)(((int16_t)valY) % ((int16_t)valZ)));
    }
    break;
  case 0x17:
    // frac
    {
      uint16_t valY = getR(registerY);
      uint16_t valZ = getR(registerZ);
      setR(registerX, (uint16_t)((((uint32_t)valY) << 16) / valZ));
    }
    break;
  case 0x18:
    // sfrac
    {
      uint16_t valY = getR(registerY);
      uint16_t valZ = getR(registerZ);
      setR(registerX, (uint16_t)((((int32_t)valY) << 16) / ((int16_t)valZ)));
      // TODO: CHECK -- NOT SURE IF THIS IS CORRECT?
    }
    break;
  case 0x19:
    // ==
    {
      uint16_t valY = getR(registerY);
      uint16_t valZ = getR(registerZ);
      setR(registerX, valY == valZ);
    }
    break;
  case 0x1a:
    // !=
    {
      uint16_t valY = getR(registerY);
      uint16_t valZ = getR(registerZ);
      setR(registerX, valY != valZ);
    }
    break;
  case 0x1b:
    // <
    {
      uint16_t valY = getR(registerY);
      uint16_t valZ = getR(registerZ);
      setR(registerX, valY < valZ);
    }
    break;
  case 0x1c:
    // s<
    {
      uint16_t valY = getR(registerY);
      uint16_t valZ = getR(registerZ);
      setR(registerX, ((int16_t)valY) < ((int16_t)valZ));
    }
    break;
  case 0x1d:
    // <=
    {
      uint16_t valY = getR(registerY);
      uint16_t valZ = getR(registerZ);
      setR(registerX, valY <= valZ);
    }
    break;
  case 0x1e:
    // s<=
    {
      uint16_t valY = getR(registerY);
      uint16_t valZ = getR(registerZ);
      setR(registerX, ((int16_t)valY) <= ((int16_t)valZ));
    }
    break;
  case 0x1f:
    // &
    {
      uint16_t valY = getR(registerY);
      uint16_t valZ = getR(registerZ);
      setR(registerX, valY & valZ);
    }
    break;
  case 0x20:
    // &&
    {
      uint16_t valY = getR(registerY);
      uint16_t valZ = getR(registerZ);
      setR(registerX, valY && valZ);
    }
    break;
  case 0x21:
    // |
    {
      uint16_t valY = getR(registerY);
      uint16_t valZ = getR(registerZ);
      setR(registerX, valY | valZ);
    }
    break;
  case 0x22:
    // ^
    {
      uint16_t valY = getR(registerY);
      uint16_t valZ = getR(registerZ);
      setR(registerX, valY ^ valZ);
    }
    break;
  case 0x23:
    // <<
    {
      uint16_t valY = getR(registerY);
      uint16_t valZ = getR(registerZ);
      setR(registerX, valY << valZ);
    }
    break;
  case 0x24:
    // >>
    {
      uint16_t valY = getR(registerY);
      uint16_t valZ = getR(registerZ);
      setR(registerX, valY >> valZ);
    }
    break;
  case 0x25:
    // ?
    {
      uint16_t valY = getR(registerY);
      uint16_t valZ = getR(registerZ);
      if (valY == 0)
        setR(registerX, valZ);
    }
    break;
  case 0x26:
    // absgn
    {
      uint16_t valZ = getR(registerZ);
      if (valZ > 0) {
        setR(registerX, valZ);
        setR(registerY, 1);
      }
      else if (valZ < 0) {
        setR(registerX, -valZ);
        setR(registerY, -1);
      }
      else {
        setR(registerX, 0);
        setR(registerY, 0);
      }
    }
    break;
  case 0x27:
    // sqrt
    {
      uint16_t valZ = getR(registerZ);
      float answer = sqrt(valZ);
      uint32_t ans2 = (uint32_t)(answer * 65536);
      setR(registerX, (uint16_t)(ans2 >> 16));
      setR(registerY, (uint16_t)ans2);
    }
    break;
  case 0x28:
    // red
    {
      uint16_t valY = getR(registerY);
      uint16_t valZ = getR(registerZ);
      setR(registerX, ((valZ & 0xf8) << 8) | (valY & 0x07ff));
    }
    break;
  case 0x29:
    // green
    {
      uint16_t valY = getR(registerY);
      uint16_t valZ = getR(registerZ);
      setR(registerX, ((valZ & 0xfc) << 3) | (valY & 0xf81f));
    }
    break;
  case 0x2a:
    // blue
    {
      uint16_t valY = getR(registerY);
      uint16_t valZ = getR(registerZ);
      setR(registerX, ((valZ & 0xf8) >> 3) | (valY & 0xffe0));
    }
    break;
  case 0x2b:
    // +c
    {
      uint16_t valY = getR(registerY);
      uint16_t valZ = getR(registerZ);
      setR(registerX, ((uint32_t)(valY) + (uint32_t)(valZ)) >> 16);
    }
    break;
  case 0x2c:
    // -c
    {
      uint16_t valY = getR(registerY);
      uint16_t valZ = getR(registerZ);
      setR(registerX, ((uint32_t)(valY) - (uint32_t)(valZ)) >> 16);
    }
    break;
  case 0x2d:
    // *c
    {
      uint16_t valY = getR(registerY);
      uint16_t valZ = getR(registerZ);
      setR(registerX, ((uint32_t)(valY) * (uint32_t)(valZ)) >> 16);
    }
    break;
  case 0x2e:
    // conc
    {
      uint16_t valY = getR(registerY);
      uint16_t valZ = getR(registerZ);
      setR(registerX, (valY << 8) | (valZ & 0xff));
    }
    break;
  case 0x2f:
    // high
    {
      uint16_t valY = getR(registerY);
      setR(registerX, valY >> 8);
    }
    break;
  case 0x30:
    // =
    setR(registerX, getR(registerY));
    break;
  case 0x31:
    // =
    setR(registerX, inst2);
    break;
  case 0x32:
    // load
    setR(registerX, memory[getR(registerY)]);
    break;
  case 0x33:
    // load
    setR(registerX, memory[inst2]);
    break;
  case 0x34:
    // store
    {
      uint16_t addr = getR(registerY);
      if (addr > 2 && addr < 8192)
        memory[addr] = getR(registerX);
    }
    break;
  case 0x35:
    // store
    {
      uint16_t addr = inst2;
      if (addr > 2 && addr < 8192)
        memory[addr] = getR(registerX);
    }
    break;
  case 0x36:
    // window
    {
      uint16_t addr = getR(registerY);
      if (addr < 8192 - 128)
        window_pointer = addr;
    }
    break;
  case 0x37:
    // window
    {
      uint16_t addr = inst2;
      if (addr < 8192 - 128)
        window_pointer = addr;
    }
    break;
  case 0x38:
    // skip
    {
      uint16_t addr = getR(registerY);
      if (addr < 8192) {
        stack_size = 0;
        instruction_pointer = addr - 2;
        has_jumped = true;
      }
    }
    break;
  case 0x39:
    // skip
    {
      uint16_t addr = inst2;
      if (addr < 8192) {
        stack_size = 0;
        instruction_pointer = addr - 2;
        has_jumped = true;
      }
    }
    break;
  case 0x3a:
    // skim
    {
      uint16_t addr = getR(registerY);
      uint16_t maxaddr = (addr & 0xf800) + 2048;
      if (maxaddr > 8192)
        maxaddr = 8192;
      for (uint16_t ptr = addr & 0xfffe; ptr < maxaddr; ptr += 2) {
        if ((memory[ptr] & 0xff) == 0x08)
          routines[memory[ptr] >> 8] = ptr + 2;
      }
    }
    break;
  case 0x3b:
    // skim
    {
      uint16_t addr = inst2;
      uint16_t maxaddr = (addr & 0xf800) + 2048;
      if (maxaddr > 8192)
        maxaddr = 8192;
      for (uint16_t ptr = addr & 0xfffe; ptr < maxaddr; ptr += 2) {
        if ((memory[ptr] & 0xff) == 0x08)
          routines[memory[ptr] >> 8] = ptr + 2;
      }
    }
    break;
  case 0x40:
    // read
    readPage(getR(registerX), getR(registerY));
    break;
  case 0x41:
    // read
    readPage(getR(registerX), inst2);
    break;
  case 0x42:
    // write
    writePage(getR(registerX), getR(registerY));
    break;
  case 0x43:
    // write
    writePage(getR(registerX), inst2);
    break;
  case 0x44:
    // readb
    {
      String indexStr = String(getR(registerX), HEX);
      while (indexStr.length() < 4)
        indexStr = "0" + indexStr;
      String fname = "B" + indexStr + ".bin";
      if (SD.exists(fname.c_str())) {
        File file = SD.open(fname.c_str());
        file.read((uint8_t*)background, 6144);
        file.close();
      }
    }
    break;
  case 0x45:
    // reads
    {
      uint16_t ry = getR(registerY);
      if (ry > 1)
        break;
      String indexStr = String(getR(registerX), HEX);
      while (indexStr.length() < 4)
        indexStr = "0" + indexStr;
      String fname = "S" + indexStr + ".bin";
      if (SD.exists(fname.c_str())) {
        File file = SD.open(fname.c_str());
        file.read((uint8_t*)spritesheets + 3072 * ry, 3072);
        file.close();
      }
    }
    break;
  case 0x46:
    // readp
    {
      String indexStr = String(getR(registerX), HEX);
      while (indexStr.length() < 4)
        indexStr = "0" + indexStr;
      String fname = "P" + indexStr + ".bin";
      if (SD.exists(fname.c_str())) {
        File file = SD.open(fname.c_str());
        file.read((uint8_t*)palette, 1024);
        file.close();
      }
    }
    break;
  case 0x47:
    // rex
    {
      if (sdCardValid) {
        uint16_t current_page = instruction_pointer & 0xf800;
        readPage(getR(registerX), current_page);
        instruction_pointer = current_page - 2;
        stack_size = 0;
        has_jumped = true;
        p[0].playheadEnabled = false;
        p[1].playheadEnabled = false;
      }
      else {
        memcpy_P(background, sd_error, 6144);
        for (int y = 0; y < 64; y++) {
          for (int x = 0; x < 96; x++) {
            framebuffer[y][x] = (uint8_t)(background[y][x] + palette_offset);
          }
        }
        uint16_t row[96];
        tft.startPushData(0, 0, 95, 63);
        GPIO_REG_WRITE(GPIO_OUT_W1TS_ADDRESS, _BV(__DC));
        for (int y = 0; y < 64; y++) {
          for (int x = 0; x < 96; x++)
            row[x] = ((palette[framebuffer[y][x]] >> 8) & 0xff) | (palette[framebuffer[y][x]] << 8);
          SPI.writeBytes((uint8_t*)row, 192);
          processSound();
        }
        tft.endPushData();
        while (true) {
          processSound();
        }
      }
    }
    break;
  case 0x50:
    // refresh
    {
    uint32_t m1 = millis();
    for (int yy = 0; yy < 64; yy += Y_SKIP) {
      for (int xx = 0; xx < 96; xx += X_SKIP) {
        /*uint32_t csum = 0;
        uint32_t s1 = 1;
        uint32_t s2 = 0;
        for (int y = yy; y < yy+Y_SKIP; y++) {
          for (int x = xx; x < xx+X_SKIP; x++) {
            s1 = (s1 + framebuffer[y][x]) % 65521;
            s2 = (s2 + s1) % 65521;
          }
        }
        csum = (s2 << 16) | s1;
        if (csum == checksums[yy/Y_SKIP][xx/X_SKIP])
          continue;
        checksums[yy/Y_SKIP][xx/X_SKIP] = csum;*/
        uint16_t row[96];
        tft.startPushData(xx, yy, xx+X_SKIP-1, yy+Y_SKIP-1);
        // GPIO_REG_WRITE(GPIO_OUT_W1TC_ADDRESS, _BV(__CS));
        // GPIO_REG_WRITE(GPIO_OUT_W1TC_ADDRESS, _BV(__DC)); // enableCommandStream
        // SPI.write(CMD_SETCOLUMN); //Column
        // SPI.write(xx); SPI.write(xx+X_SKIP-1);
        // SPI.write(CMD_SETROW); //Page
        // SPI.write(yy); SPI.write(yy+Y_SKIP-1);
        /*for (int y = yy; y < yy+Y_SKIP; y++) {
          for (int x = xx; x < xx+X_SKIP; x+=2) {
            GPIO_REG_WRITE(GPIO_OUT_W1TS_ADDRESS, _BV(__DC)); // enableDataStream
            SPI.write32((framebuffer[y][x] << 16) | (framebuffer[y][x+1])); // spiwrite16
            // tft.pushData(framebuffer[y][x]);
            // tft.drawPixel(x, y, framebuffer[y][x]); WAY SLOW
          }
        }*/
        GPIO_REG_WRITE(GPIO_OUT_W1TS_ADDRESS, _BV(__DC));
        for (int y = 0; y < 64; y++) {
          for (int x = 0; x < 96; x++)
            row[x] = ((palette[framebuffer[y][x]] >> 8) & 0xff) | (palette[framebuffer[y][x]] << 8);
          SPI.writeBytes((uint8_t*)row, 192);
          processSound();
        }
        tft.endPushData();
        // GPIO_REG_WRITE(GPIO_OUT_W1TS_ADDRESS, _BV(__CS));
      }
    }
    if (millis() == m1)
      delay(1); // For sanity
    }
    break;
  case 0x51:
    // clear
    {
      uint8_t color = getR(registerX);
      for (int y = 0; y < 64; y++) {
        for (int x = 0; x < 96; x++) {
          framebuffer[y][x] = color;
          if (x < 48)
            flagbuffer[y][x] = 0;
        }
      }
    }
    break;
  case 0x52:
    // dbg
    {
      uint16_t valX = getR(registerX);
      uint8_t rowX = (uint8_t)(valX);
      uint8_t colX = (uint8_t)(valX >> 8);
      for (int y = 0; y < 64; y++) {
        for (int x = 0; x < 96; x++) {
          int y2 = y + rowX;
          if (y2 < 0)
            y2 += 64;
          y2 = y2 % 64;
          int x2 = x + colX;
          if (x2 < 0)
            x2 += 96;
          x2 = x2 % 96;
          uint32_t color = palette[(uint8_t)(background[y2][x2] + palette_offset)];
          if ((x & 1) == 0)
            flagbuffer[y][x >> 1] |= (uint8_t)((color & 0x00f00000) >> 16);
          else
            flagbuffer[y][x >> 1] |= (uint8_t)((color & 0x00f00000) >> 20);
          if ((color & 0x00010000) == 0)
            framebuffer[y][x] = (uint8_t)(background[y2][x2] + palette_offset);
        }
      }
    }
    break;
  case 0x53:
    // dbg16
    {
      uint16_t valX = getR(registerX);
      uint16_t valY = getR(registerY);
      int8_t rowX = (int8_t)(valX);
      int8_t colX = (int8_t)(valX >> 8);
      int8_t rowY = (int8_t)(valY);
      int8_t colY = (int8_t)(valY >> 8);
      for (int r = 0; r < 16; r++) {
        for (int c = 0; c < 16; c++) {
          if (rowY + r < 0)
            continue;
          if (rowY + r >= 64)
            continue;
          if (colY + c < 0)
            continue;
          if (colY + c >= 96)
            continue;
          uint32_t color = palette[(uint8_t)(background[r + rowX][c + colX] + palette_offset)];
          if (((colY + c) & 1) == 0)
            flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 16);
          else
            flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 20);
          if ((color & 0x00010000) == 0)
            framebuffer[rowY + r][colY + c] = (uint8_t)(background[r + rowX][c + colX] + palette_offset);
        }
      }
    }
    break;
  case 0x54:
    // dbg8
    {
      uint16_t valX = getR(registerX);
      uint16_t valY = getR(registerY);
      int8_t rowX = (int8_t)(valX);
      int8_t colX = (int8_t)(valX >> 8);
      int8_t rowY = (int8_t)(valY);
      int8_t colY = (int8_t)(valY >> 8);
      for (int r = 0; r < 8; r++) {
        for (int c = 0; c < 8; c++) {
          if (rowY + r < 0)
            continue;
          if (rowY + r >= 64)
            continue;
          if (colY + c < 0)
            continue;
          if (colY + c >= 96)
            continue;
          uint32_t color = palette[(uint8_t)(background[r + rowX][c + colX] + palette_offset)];
          if (((colY + c) & 1) == 0)
            flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 16);
          else
            flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 20);
          if ((color & 0x00010000) == 0)
            framebuffer[rowY + r][colY + c] = (uint8_t)(background[r + rowX][c + colX] + palette_offset);
        }
      }
    }
    break;
  case 0x55:
    // dbg4
    {
      uint16_t valX = getR(registerX);
      uint16_t valY = getR(registerY);
      int8_t rowX = (int8_t)(valX);
      int8_t colX = (int8_t)(valX >> 8);
      int8_t rowY = (int8_t)(valY);
      int8_t colY = (int8_t)(valY >> 8);
      for (int r = 0; r < 4; r++) {
        for (int c = 0; c < 4; c++) {
          if (rowY + r < 0)
            continue;
          if (rowY + r >= 64)
            continue;
          if (colY + c < 0)
            continue;
          if (colY + c >= 96)
            continue;
          uint32_t color = palette[(uint8_t)(background[r + rowX][c + colX] + palette_offset)];
          if (((colY + c) & 1) == 0)
            flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 16);
          else
            flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 20);
          if ((color & 0x00010000) == 0)
            framebuffer[rowY + r][colY + c] = (uint8_t)(background[r + rowX][c + colX] + palette_offset);
        }
      }
    }
    break;
  case 0x56:
    // dbg
    {
      uint16_t valX = getR(registerX);
      uint16_t valY = getR(registerY);
      uint16_t valZ = getR(registerZ);
      int8_t rowX = (int8_t)(valX);
      int8_t colX = (int8_t)(valX >> 8);
      int8_t rowY = (int8_t)(valY);
      int8_t colY = (int8_t)(valY >> 8);
      uint8_t widZ = (uint8_t)(valZ);
      uint8_t heiZ = (uint8_t)(valZ >> 8);
      for (int r = 0; r < heiZ; r++) {
        for (int c = 0; c < widZ; c++) {
          if (rowY + r < 0)
            continue;
          if (rowY + r >= 64)
            continue;
          if (colY + c < 0)
            continue;
          if (colY + c >= 96)
            continue;
          uint32_t color = palette[(uint8_t)(background[r + rowX][c + colX] + palette_offset)];
          if (((colY + c) & 1) == 0)
            flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 16);
          else
            flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 20);
          if ((color & 0x00010000) == 0)
            framebuffer[rowY + r][colY + c] = (uint8_t)(background[r + rowX][c + colX] + palette_offset);
        }
      }
    }
    break;
  case 0x57:
    // dss
    {
      uint16_t valX = getR(registerX);
      int8_t rowX = (int8_t)(valX);
      int8_t colX = (int8_t)(valX >> 8);
      for (int r = 0; r < 64; r++) {
        for (int c = 0; c < 96; c++) {
          uint8_t indices = spritesheets[(r + rowX) >> 6][(r + rowX) & 0x3f][(c + colX) >> 1];
          uint8_t index = indices & 0xf;
          if (((c + colX) & 1) == 0)
            index = indices >> 4;
          uint32_t color = palette[(uint8_t)(index + palette_offset)];
          if ((c & 1) == 0)
            flagbuffer[r][c >> 1] |= (uint8_t)((color & 0x00f00000) >> 16);
          else
            flagbuffer[r][c >> 1] |= (uint8_t)((color & 0x00f00000) >> 20);
          if ((color & 0x00010000) == 0)
            framebuffer[r][c] = (uint8_t)(index + palette_offset);
        }
      }
    }
    break;
  case 0x58:
    // dss16
    {
      uint16_t valX = getR(registerX);
      uint16_t valY = getR(registerY);
      int8_t rowX = (int8_t)(valX);
      int8_t colX = (int8_t)(valX >> 8);
      int8_t rowY = (int8_t)(valY);
      int8_t colY = (int8_t)(valY >> 8);
      for (int r = 0; r < 16; r++) {
        for (int c = 0; c < 16; c++) {
          if (rowY + r < 0)
            continue;
          if (rowY + r >= 64)
            continue;
          if (colY + c < 0)
            continue;
          if (colY + c >= 96)
            continue;
          uint8_t indices = spritesheets[(r + rowX) >> 6][(r + rowX) & 0x3f][(c + colX) >> 1];
          uint8_t index = indices & 0xf;
          if (((c + colX) & 1) == 0)
            index = indices >> 4;
          uint32_t color = palette[(uint8_t)(index + palette_offset)];
          if (((colY + c) & 1) == 0)
            flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 16);
          else
            flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 20);
          if ((color & 0x00010000) == 0)
            framebuffer[rowY + r][colY + c] = (uint8_t)(index + palette_offset);
        }
      }
    }
    break;
  case 0x59:
    // dss8
    {
      uint16_t valX = getR(registerX);
      uint16_t valY = getR(registerY);
      int8_t rowX = (int8_t)(valX);
      int8_t colX = (int8_t)(valX >> 8);
      int8_t rowY = (int8_t)(valY);
      int8_t colY = (int8_t)(valY >> 8);
      for (int r = 0; r < 8; r++) {
        for (int c = 0; c < 8; c++) {
          if (rowY + r < 0)
            continue;
          if (rowY + r >= 64)
            continue;
          if (colY + c < 0)
            continue;
          if (colY + c >= 96)
            continue;
          uint8_t indices = spritesheets[(r + rowX) >> 6][(r + rowX) & 0x3f][(c + colX) >> 1];
          uint8_t index = indices & 0xf;
          if (((c + colX) & 1) == 0)
            index = indices >> 4;
          uint32_t color = palette[(uint8_t)(index + palette_offset)];
          if (((colY + c) & 1) == 0)
            flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 16);
          else
            flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 20);
          if ((color & 0x00010000) == 0)
            framebuffer[rowY + r][colY + c] = (uint8_t)(index + palette_offset);
        }
      }
    }
    break;
  case 0x5a:
    // dss4
    {
      uint16_t valX = getR(registerX);
      uint16_t valY = getR(registerY);
      int8_t rowX = (int8_t)(valX);
      int8_t colX = (int8_t)(valX >> 8);
      int8_t rowY = (int8_t)(valY);
      int8_t colY = (int8_t)(valY >> 8);
      for (int r = 0; r < 4; r++) {
        for (int c = 0; c < 4; c++) {
          if (rowY + r < 0)
            continue;
          if (rowY + r >= 64)
            continue;
          if (colY + c < 0)
            continue;
          if (colY + c >= 96)
            continue;
          uint8_t indices = spritesheets[(r + rowX) >> 6][(r + rowX) & 0x3f][(c + colX) >> 1];
          uint8_t index = indices & 0xf;
          if (((c + colX) & 1) == 0)
            index = indices >> 4;
          uint32_t color = palette[(uint8_t)(index + palette_offset)];
          if (((colY + c) & 1) == 0)
            flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 16);
          else
            flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 20);
          if ((color & 0x00010000) == 0)
            framebuffer[rowY + r][colY + c] = (uint8_t)(index + palette_offset);
        }
      }
    }
    break;
  case 0x5b:
    // dss
    {
      uint16_t valX = getR(registerX);
      uint16_t valY = getR(registerY);
      uint16_t valZ = getR(registerZ);
      int8_t rowX = (int8_t)(valX);
      int8_t colX = (int8_t)(valX >> 8);
      int8_t rowY = (int8_t)(valY);
      int8_t colY = (int8_t)(valY >> 8);
      uint8_t widZ = (uint8_t)(valZ);
      uint8_t heiZ = (uint8_t)(valZ >> 8);
      for (int r = 0; r < heiZ; r++) {
        for (int c = 0; c < widZ; c++) {
          if (rowY + r < 0)
            continue;
          if (rowY + r >= 64)
            continue;
          if (colY + c < 0)
            continue;
          if (colY + c >= 96)
            continue;
          uint8_t indices = spritesheets[(r + rowX) >> 6][(r + rowX) & 0x3f][(c + colX) >> 1];
          uint8_t index = indices & 0xf;
          if (((c + colX) & 1) == 0)
            index = indices >> 4;
          uint32_t color = palette[(uint8_t)(index + palette_offset)];
          if (((colY + c) & 1) == 0)
            flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 16);
          else
            flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 20);
          if ((color & 0x00010000) == 0)
            framebuffer[rowY + r][colY + c] = (uint8_t)(index + palette_offset);
        }
      }
    }
    break;
  case 0x5c:
    // dpx
    {
      uint16_t valX = getR(registerX);
      uint16_t valY = getR(registerY);
      int8_t rowX = (int8_t)(valX);
      int8_t colX = (int8_t)(valX >> 8);
      if (rowX < 0)
        break;
      if (rowX >= 64)
        break;
      if (colX < 0)
        break;
      if (colX >= 96)
        break;
      framebuffer[rowX][colX] = (uint8_t)(valY);
    }
    break;
  case 0x5d:
    // dchar
    {
      uint16_t valX = getR(registerX);
      uint16_t valY = getR(registerY);
      uint16_t valZ = getR(registerZ);
      int8_t rowX = (int8_t)((valX << 6) + (valZ >> 4) * 8);
      int8_t colX = (int8_t)((valZ & 0xf) * 6);
      int8_t rowY = (uint8_t)(valY);
      int8_t colY = (int8_t)(valY >> 8);
      for (int r = 0; r < 8; r++) {
        for (int c = 0; c < 6; c++) {
          if (rowY + r < 0)
            continue;
          if (rowY + r >= 64)
            continue;
          if (colY + c < 0)
            continue;
          if (colY + c >= 96)
            continue;
          uint8_t indices = spritesheets[(r + rowX) >> 6][(r + rowX) & 0x3f][(c + colX) >> 1];
          uint8_t index = indices & 0xf;
          if (((c + colX) & 1) == 0)
            index = indices >> 4;
          uint32_t color = palette[(uint8_t)(index + palette_offset)];
          if (((colY + c) & 1) == 0)
            flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 16);
          else
            flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 20);
          if ((color & 0x00010000) == 0)
            framebuffer[rowY + r][colY + c] = (uint8_t)(index + palette_offset);
        }
      }
    }
    break;
  case 0x5e:
    // dstr
    {
      uint16_t valX = getR(registerX);
      uint16_t valY = getR(registerY);
      uint16_t valZ = getR(registerZ);
      int8_t rowY = (int8_t)(valY);
      int8_t colY = (int8_t)(valY >> 8);
      uint16_t pointer = valZ * 2;
      while (true) {
        uint8_t charInd = *((uint8_t*)(memory) + pointer);
        if (charInd == 0)
          break;
        if (charInd == 13) {
          colY -= 96;
          while (colY >= 96)
            colY += 6;
          pointer++;
          continue;
        }
        if (charInd == 10) {
          colY -= 96;
          while (colY >= 96)
            colY += 6;
          rowY += 8;
          pointer++;
          continue;
        }
        if (charInd == 127) {
          pointer++;
          continue;
        }
        int8_t rowX = (int8_t)((valX << 6) + (charInd >> 4) * 8);
        int8_t colX = (int8_t)((charInd & 0xf) * 6);
        for (int r = 0; r < 8; r++) {
          for (int c = 0; c < 6; c++) {
            if (rowY + r < 0)
              continue;
            if (rowY + r >= 64)
              continue;
            if (colY + c < 0)
              continue;
            if (colY + c >= 96)
              continue;
            uint8_t indices = spritesheets[(r + rowX) >> 6][(r + rowX) & 0x3f][(c + colX) >> 1];
            uint8_t index = indices & 0xf;
            if (((c + colX) & 1) == 0)
              index = indices >> 4;
            uint32_t color = palette[(uint8_t)(index + palette_offset)];
            if (((colY + c) & 1) == 0)
              flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 16);
            else
              flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 20);
            if ((color & 0x00010000) == 0)
              framebuffer[rowY + r][colY + c] = (uint8_t)(index + palette_offset);
          }
        }

        pointer++;
        colY += 6;
        if (colY > 90) {
          colY -= 96;
          if (colY >= 96)
            colY += 6;
          rowY += 8;
        }
      }
    }
    break;
  case 0x60:
    // clearp
    {
      uint32_t color = (uint32_t)(getR(registerY)) | ((uint32_t)(getR(registerZ)) << 16);
      for (int i = 0; i < 256; i++) {
        palette[i] = color;
      }
    }
    break;
  case 0x61:
    // setp
    {
      uint32_t color = (uint32_t)(getR(registerY)) | ((uint32_t)(getR(registerZ)) << 16);
      uint8_t i = getR(registerX);
      palette[i] = color;
    }
    break;
  case 0x62:
    // getp
    {
      uint8_t i = getR(registerX);
      uint32_t color = palette[i];
      setR(registerY, (uint16_t)color);
      setR(registerZ, (uint16_t)(color >> 16));
    }
    break;
  case 0x63:
    // setpoffs
    palette_offset = (uint8_t)(getR(registerY));
    break;
  case 0x64:
    // setpoffs
    palette_offset = (uint8_t)(inst2);
    break;
  case 0x70:
    // frame
    {
      uint16_t rate = getR(registerX);
      if (rate == 0)
        rate = 33; // Backwards compatibility
      if (millis() - DEBUG_UINT32 > rate - 3) {
        Serial.print("Frame warning: ");
        Serial.println(millis() - DEBUG_UINT32);
      }
      while (true) {
        uint32_t m = millis();
        if ((m % 100) % rate == 0)
          break;
        /*if (m % 100 == 0 || m % 100 == 33 || m % 100 == 67)
          break;*/
        processSound();
      }
      DEBUG_UINT32 = millis();
      //Serial.println(ESP.getFreeHeap());
    }
    break;
  case 0x71:
    // delay
    {
      uint16_t ms = getR(registerY);
      uint32_t newMillis = millis() + ms;
      while (millis() < newMillis) {
        processSound();
      }
    }
    break;
  case 0x72:
    // delay
    {
      uint16_t ms = inst2;
      uint32_t newMillis = millis() + ms;
      while (millis() < newMillis) {
        processSound();
      }
    }
    break;
  case 0x80:
    // button
    {
      uint16_t val = getR(registerY);
      if (val > 7)
        break;
      setR(registerX, input_state[val]);
    }
    break;
  case 0x81:
    // button
    {
      uint16_t val = inst2;
      if (val > 7)
        break;
      setR(registerX, input_state[val]);
    }
    break;
  case 0x82:
    // buttonp
    {
      uint16_t val = getR(registerY);
      if (val > 7)
        break;
      setR(registerX, input_state[val] && !input_state_prev[val]);
    }
    break;
  case 0x83:
    // buttonp
    {
      uint16_t val = inst2;
      if (val > 7)
        break;
      setR(registerX, input_state[val] && !input_state_prev[val]);
    }
    break;
  case 0x84:
    // buttonr
    {
      uint16_t val = getR(registerY);
      if (val > 7)
        break;
      setR(registerX, !input_state[val] && input_state_prev[val]);
    }
    break;
  case 0x85:
    // buttonr
    {
      uint16_t val = inst2;
      if (val > 7)
        break;
      setR(registerX, !input_state[val] && input_state_prev[val]);
    }
    break;
  case 0x90:
    // colflags
    test_flags = getR(registerY) & 0xf;
    break;
  case 0x91:
    // colflags
    test_flags = inst2 & 0xf;
    break;
  case 0x92:
    // col
    {
      bool done = 0;
      for (int y = 0; y < 64; y++) {
        for (int x = 0; x < 96; x++) {
          uint8_t flags;
          if ((x & 1) == 1)
            flags = flagbuffer[y][x >> 1] & 0xf;
          else
            flags = flagbuffer[y][x >> 1] >> 4;
          if ((flags & test_flags) == test_flags) {
            done = 1;
            break;
          }
        }
        if (done)
          break;
      }
      setR(registerX, done);
    }
    break;
  case 0x93:
    // col16
    {
      bool done = 0;
      uint16_t valY = getR(registerY);
      int8_t rowY = (int8_t)(valY);
      int8_t colY = (int8_t)(valY >> 8);
      for (int r = 0; r < 16; r++) {
        for (int c = 0; c < 16; c++) {
          if (rowY + r < 0)
            continue;
          if (rowY + r >= 64)
            continue;
          if (colY + c < 0)
            continue;
          if (colY + c >= 96)
            continue;
          uint8_t flags;
          if (((colY + c) & 1) == 1)
            flags = flagbuffer[rowY + r][(colY + c) >> 1] & 0xf;
          else
            flags = flagbuffer[rowY + r][(colY + c) >> 1] >> 4;
          if ((flags & test_flags) == test_flags) {
            done = 1;
            break;
          }
        }
        if (done)
          break;
      }
      setR(registerX, done);
    }
    break;
  case 0x94:
    // col8
    {
      bool done = 0;
      uint16_t valY = getR(registerY);
      int8_t rowY = (int8_t)(valY);
      int8_t colY = (int8_t)(valY >> 8);
      for (int r = 0; r < 8; r++) {
        for (int c = 0; c < 8; c++) {
          if (rowY + r < 0)
            continue;
          if (rowY + r >= 64)
            continue;
          if (colY + c < 0)
            continue;
          if (colY + c >= 96)
            continue;
          uint8_t flags;
          if (((colY + c) & 1) == 1)
            flags = flagbuffer[rowY + r][(colY + c) >> 1] & 0xf;
          else
            flags = flagbuffer[rowY + r][(colY + c) >> 1] >> 4;
          if ((flags & test_flags) == test_flags) {
            done = 1;
            break;
          }
        }
        if (done)
          break;
      }
      setR(registerX, done);
    }
    break;
  case 0x95:
    // col4
    {
      bool done = 0;
      uint16_t valY = getR(registerY);
      int8_t rowY = (int8_t)(valY);
      int8_t colY = (int8_t)(valY >> 8);
      for (int r = 0; r < 4; r++) {
        for (int c = 0; c < 4; c++) {
          if (rowY + r < 0)
            continue;
          if (rowY + r >= 64)
            continue;
          if (colY + c < 0)
            continue;
          if (colY + c >= 96)
            continue;
          uint8_t flags;
          if (((colY + c) & 1) == 1)
            flags = flagbuffer[rowY + r][(colY + c) >> 1] & 0xf;
          else
            flags = flagbuffer[rowY + r][(colY + c) >> 1] >> 4;
          if ((flags & test_flags) == test_flags) {
            done = 1;
            break;
          }
        }
        if (done)
          break;
      }
      setR(registerX, done);
    }
    break;
  case 0x96:
    // col
    {
      bool done = 0;
      uint16_t valY = getR(registerY);
      uint16_t valZ = getR(registerZ);
      int8_t rowY = (int8_t)(valY);
      int8_t colY = (int8_t)(valY >> 8);
      uint8_t widZ = (uint8_t)(valZ);
      uint8_t heiZ = (uint8_t)(valZ >> 8);
      for (int r = 0; r < heiZ; r++) {
        for (int c = 0; c < widZ; c++) {
          if (rowY + r < 0)
            continue;
          if (rowY + r >= 64)
            continue;
          if (colY + c < 0)
            continue;
          if (colY + c >= 96)
            continue;
          uint8_t flags;
          if (((colY + c) & 1) == 1)
            flags = flagbuffer[rowY + r][(colY + c) >> 1] & 0xf;
          else
            flags = flagbuffer[rowY + r][(colY + c) >> 1] >> 4;
          if ((flags & test_flags) == test_flags) {
            done = 1;
            break;
          }
        }
        if (done)
          break;
      }
      setR(registerX, done);
    }
    break;
  case 0xa0:
    // itoa
    {
      uint16_t addr = getR(registerY);
      String str = String((uint16_t)getR(registerX));
      memcpy((void*)(&memory[addr]), (void*)(str.c_str()), 8);
    }
    break;
  case 0xa1:
    // itoa
    {
      uint16_t addr = inst2;
      String str = String((uint16_t)getR(registerX));
      memcpy((void*)(&memory[addr]), (void*)(str.c_str()), 8);
    }
    break;
  case 0xa2:
    // sitoa
    {
      uint16_t addr = getR(registerY);
      String str = String((int16_t)getR(registerX));
      memcpy((void*)(&memory[addr]), (void*)(str.c_str()), 8);
    }
    break;
  case 0xa3:
    // sitoa
    {
      uint16_t addr = inst2;
      String str = String((int16_t)getR(registerX));
      memcpy((void*)(&memory[addr]), (void*)(str.c_str()), 8);
    }
    break;
  case 0xa4:
    // strw
    {
      
      uint16_t pointer = getR(registerY) * 2;
      uint16_t w = 0;
      uint16_t maxW = 0;
      while (true) {
        uint8_t charInd = *((uint8_t*)(memory) + pointer);
        if (charInd == 0)
          break;
        if (charInd == 13) {
          w = 0;
          pointer++;
          continue;
        }
        if (charInd == 10) {
          w = 0;
          pointer++;
          continue;
        }
        if (charInd == 127) {
          pointer++;
          continue;
        }
        w += 6;
        if (w > maxW)
          maxW = w;
        pointer++;
      }
      setR(registerX, maxW);
    }
    break;
  case 0xa5:
    // strh
    {
      
      uint16_t pointer = getR(registerY) * 2;
      uint16_t h = 8;
      while (true) {
        uint8_t charInd = *((uint8_t*)(memory) + pointer);
        if (charInd == 0)
          break;
        if (charInd == 13) {
          h += 8;
          pointer++;
          continue;
        }
        if (charInd == 10) {
          h += 8;
          pointer++;
          continue;
        }
        if (charInd == 127) {
          pointer++;
          continue;
        }
        pointer++;
      }
      setR(registerX, h);
    }
    break;
  case 0xb0:
    // loadsnd
    {
      uint16_t addr = getR(registerY);
      uint16_t maxaddr = (addr & 0xf800) + 2048;
      uint8_t *start_address = (uint8_t*)(&memory[addr]);
      uint8_t *end_address = (uint8_t*)(&memory[maxaddr]);
      for (uint8_t *i = start_address; i + 2 < end_address; i += 3) {
        if (*(i + 1) == 0x04) {
          patterns[*(i + 2)] = i;
        }
      }
    }
    break;
  case 0xb1:
    // loadsnd
    {
      uint16_t addr = inst2;
      uint16_t maxaddr = (addr & 0xf800) + 2048;
      uint8_t *start_address = (uint8_t*)(&memory[addr]);
      uint8_t *end_address = (uint8_t*)(&memory[maxaddr]);
      for (uint8_t *i = start_address; i + 2 < end_address; i += 3) {
        if (*(i + 1) == 0x04) {
          patterns[*(i + 2)] = i;
        }
      }
    }
    break;
  case 0xb2:
    // playsnd
    {
      uint8_t d = registerX & 1;
      uint8_t pattern = getR(registerY);
      p[d].instructionPointer = patterns[pattern];
  
      p[d].playheadEnabled = true;
      p[d].ticksToNext = 0;
      p[d].patternStackSize = 0;
  
      nextTickMicros[d] = micros();
  
      for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 4; j++) {
          p[d].startPeriod[i][j] = 0;
          p[d].targetPeriod[i][j] = 0;
        }
  
        p[d].chordSize[i] = 1;
        p[d].chordLength[i] = 1;
        p[d].chordTicks[i] = 0;
        p[d].pitchTicks[i] = 0;
        p[d].volumeMode[i] = 3;
        p[d].volumeTicks[i] = 0;
      }
  
      for (int j = 0; j < 4; j++) {
        p[d].startPeriodBass[j] = 0;
        p[d].targetPeriodBass[j] = 0;
      }
  
      p[d].chordSizeBass = 1;
      p[d].chordLengthBass = 1;
      p[d].chordTicksBass = 0;
      p[d].pitchTicksBass = 0;
      p[d].bassRunning = 0;
  
      p[d].drumTimer = 255;
      p[d].drumType = 0;
    }
    break;
  case 0xb3:
    // playsnd
    {
      uint8_t d = registerX & 1;
      uint8_t pattern = inst2;
      p[d].instructionPointer = patterns[pattern];
  
      p[d].playheadEnabled = true;
      p[d].ticksToNext = 0;
      p[d].patternStackSize = 0;
  
      nextTickMicros[d] = micros();
  
      for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 4; j++) {
          p[d].startPeriod[i][j] = 0;
          p[d].targetPeriod[i][j] = 0;
        }
  
        p[d].chordSize[i] = 1;
        p[d].chordLength[i] = 1;
        p[d].chordTicks[i] = 0;
        p[d].pitchTicks[i] = 0;
        p[d].volumeMode[i] = 3;
        p[d].volumeTicks[i] = 0;
      }
  
      for (int j = 0; j < 4; j++) {
        p[d].startPeriodBass[j] = 0;
        p[d].targetPeriodBass[j] = 0;
      }
  
      p[d].chordSizeBass = 1;
      p[d].chordLengthBass = 1;
      p[d].chordTicksBass = 0;
      p[d].pitchTicksBass = 0;
      p[d].bassRunning = 0;
  
      p[d].drumTimer = 255;
      p[d].drumType = 0;
    }
    break;
  case 0xb4:
    // stopsnd
    {
      uint8_t d = registerX & 1;
      p[d].playheadEnabled = false;
  
      setRegister(8, 0);
      setRegister(9, 0);
      setRegister(10, 0);
    }
    break;
  case 0xf0:
    // random
    {
      uint16_t val = getR(registerY);
      setR(registerX, random(val));
    }
    break;
  case 0xf1:
    // random
    {
      uint16_t val = inst2;
      setR(registerX, random(val));
    }
    break;
  }

  instruction_pointer += 2;
}
