// MyrmidonSim.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <string>
#include <sstream>
#include <iomanip>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>

#include <SDL.h>
#undef main

typedef uint8_t byte;

// Logo background
const byte logo[6144] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// SD error image
const byte sd_error[6144] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// Startup code
const byte startup[4096] = { 0xb1, 0x0, 0x0, 0x18, 0xb2, 0x0, 0x0, 0x0, 0x60, 0x0, 0x0, 0x0, 0x61, 0x1, 0x2, 0x0, 0x52, 0x0, 0x0, 0x0, 0x50, 0x0, 0x0, 0x0, 0x72, 0x0, 0x8b, 0x3, 0x51, 0x0, 0x0, 0x0, 0x50, 0x0, 0x0, 0x0, 0x72, 0x0, 0x90, 0x1, 0x31, 0x5, 0x3, 0x0, 0x41, 0x5, 0x0, 0x18, 0x31, 0x5, 0x2, 0x0, 0x41, 0x5, 0x0, 0x10, 0x40, 0x0, 0x0, 0x0, 0x47, 0x1, 0x0, 0x0 };
// Splash music
const byte splashMusic[4096] = { 0x0, 0x4, 0x0, 0x0, 0x1, 0x48, 0x0, 0x15, 0x10, 0x0, 0x10, 0x51, 0x0, 0x40, 0x31, 0x6, 0x10, 0x80, 0x6, 0x10, 0x4d, 0x6, 0x10, 0x80, 0x6, 0x10, 0x51, 0x6, 0x10, 0x80, 0x6, 0x10, 0x53, 0x0, 0x40, 0x33, 0x6, 0x10, 0x80, 0x6, 0x10, 0x4f, 0x6, 0x10, 0x80, 0x6, 0x10, 0x53, 0x6, 0x10, 0x80, 0x6, 0x10, 0x55, 0x0, 0x40, 0x34, 0x6, 0x10, 0x80, 0x1e, 0x20, 0x45, 0x6, 0x20, 0x40, 0x6, 0x20, 0x3d, 0x6, 0x20, 0x39, 0x0, 0x40, 0x80, 0x0c, 0x20, 0x80, 0x6, 0x0, 0x0, 0x90, 0x7, 0x0 };

SDL_Window* window;

uint8_t framebuffer[64][96];
uint8_t flagbuffer[64][48];
uint8_t background[64][96];
uint8_t spritesheets[2][64][48];
uint32_t palette[256];
uint8_t palette_offset;
uint8_t test_flags;

uint16_t memory[8192];
uint16_t routines[256];
uint16_t stack[32];
uint8_t stack_size;

uint16_t window_pointer;

uint16_t instruction_pointer;
bool has_jumped;

bool input_state[8];
bool input_state_prev[8];
uint32_t input_poll_time;

#define SAMPLE_RATE 44100
#define BUFFER_LENGTH 128

#pragma pack(push, 1)
struct AY38910Registers {
	uint16_t periods[3];
	uint8_t noisePeriod;
	uint8_t mixer;
	uint8_t amplitudes[3];
	uint16_t envelopePeriod;
	uint8_t envelopeType;
};
#pragma pack(pop)

AY38910Registers r;

void setRegister(uint8_t address, uint8_t value) {
	((uint8_t*)&r)[address] = value;
}

// Credits to AlanFromJapan for this array
int midiToPeriod[] = {//MIDI note number
  15289, 14431, 13621, 12856, 12135, 11454, 10811, 10204,//0-7
  9631, 9091, 8581, 8099, 7645, 7215, 6810, 6428,//8-15
  6067, 5727, 5405, 5102, 4816, 4545, 4290, 4050,//16-23
  3822, 3608, 3405, 3214, 3034, 2863, 2703, 2551,//24-31
  2408, 2273, 2145, 2025, 1911, 1804, 1703, 1607,//32-39
  1517, 1432, 1351, 1276, 1204, 1136, 1073, 1012,//40-47
  956, 902, 851, 804, 758, 716, 676, 638,//48-55
  602, 568, 536, 506, 478, 451, 426, 402,//56-63
  379, 358, 338, 319, 301, 284, 268, 253,//64-71
  239, 225, 213, 201, 190, 179, 169, 159,//72-79
  150, 142, 134, 127, 119, 113, 106, 100,//80-87
  95, 89, 84, 80, 75, 71, 67, 63,//88-95
  60, 56, 53, 50, 47, 45, 42, 40,//96-103
  38, 36, 34, 32, 30, 28, 27, 25,//104-111
  24, 22, 21, 20, 19, 18, 17, 16,//112-119
  15, 14, 13, 13, 12, 11, 11, 10,//120-127
  0//off
};

bool squares[3] = { false, false, false };
int squareClocks[3] = { 0, 0, 0 };
bool noise = false;
int noiseClock = 0;
float envelope = 0.0f;
int envelopeDir = 0;
int envelopeClock = 0;

float emas = 0.0f;

double soundClockMicros[2] = { 0.0, 0.0 };
void processSound();

void computeAudio(void *userdata, uint8_t* stream, int len) {
	int lenF = len / 4;
	float* streamF = (float*)(stream);
	for (int i = 0; i < lenF; i++) {
		int diffClocks = (int)((1.0f / SAMPLE_RATE) * 2000000.0f);

		soundClockMicros[0] += (1000000.0 / SAMPLE_RATE);
		soundClockMicros[1] += (1000000.0 / SAMPLE_RATE);

		processSound();

		// Advance square wave generators
		for (int j = 0; j < 3; j++) {
			squareClocks[j] += diffClocks;
			r.periods[j] = r.periods[j] & 4095;
			if (r.periods[j] == 0) {
				squareClocks[j] = 0;
				squares[j] = true;
			}
			else {
				while (squareClocks[j] >= r.periods[j] * 8) {
					squareClocks[j] -= r.periods[j] * 8;
					squares[j] = !squares[j];
				}
			}
		}

		// Advance noise generator
		noiseClock += diffClocks;
		r.noisePeriod = r.noisePeriod & 31;
		if (r.noisePeriod == 0) {
			noiseClock = 0;
			noise = true;
		}
		else {
			while (noiseClock >= r.noisePeriod * 16) {
				noiseClock -= r.noisePeriod * 16;
				noise = rand() & 1;
			}
		}

		// Advance envelope generator
		// TODO: When does the first period of the envelope start?
		envelopeClock += diffClocks;
		r.envelopePeriod = r.envelopePeriod & 4095;
		if (r.envelopePeriod == 0) {
			envelopeClock = 0;
			envelope = 1.0f;
		}
		else {
			while (envelopeClock >= r.envelopePeriod * 256) {
				envelopeClock -= r.envelopePeriod * 256;
				r.envelopeType = r.envelopeType & 15;

				if (r.envelopeType == 10 || r.envelopeType == 14)
					envelopeDir = (envelopeDir == 1) ? -1 : 1;
				else if (r.envelopeType == 8)
					envelopeDir = -1;
				else if (r.envelopeType == 12)
					envelopeDir = 1;
				else if (r.envelopeType < 8 || r.envelopeType == 9 || r.envelopeType == 15)
					envelopeDir = 0;
				else
					envelopeDir = 2;
			}

			float envelopeFrac = (float)envelopeClock / (r.envelopePeriod * 256);

			switch (envelopeDir) {
			case 1:
				envelope = envelopeFrac;
				break;
			case -1:
				envelope = 1.0f - envelopeFrac;
				break;
			case 2:
				envelope = 1.0f;
				break;
			default:
				envelope = 0.0f;
				break;
			}
		}

		// Compute each channel signal
		float channels[3];
		for (int j = 0; j < 3; j++) {
			// Tone enabled? Noise enabled? Neither?
			if ((r.mixer & (1 << j)) == 0) {
				channels[j] = squares[j] ? 1.0f : 0.0f;
			}
			else if ((r.mixer & (1 << (3 + j))) == 0) {
				channels[j] = noise ? 1.0f : 0.0f;
			}
			else {
				channels[j] = 1.0f;
			}

			// Multiply by amplitude (or envelope)
			if ((r.amplitudes[j] & 16) != 0) {
				channels[j] *= envelope;
			}
			else {
				channels[j] *= (float)(r.amplitudes[j] & 15) / 15.0f;
			}
		}

		// Mix!
		float value = (channels[0] + channels[1] + channels[2]) / 3.0f;
		emas = 0.01f * value + 0.99f * emas;
		streamF[i] = value - emas;
	}
}

uint8_t* patterns[256];

struct Playhead {
	uint8_t* instructionPointer = (uint8_t*)memory;
	bool playheadEnabled = false;
	uint8_t tickTime = 1;
	uint16_t ticksToNext = 0;
	uint8_t* patternStack[8];
	uint8_t patternStackSize = 0;

	uint16_t startPeriod[3][4] = { {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} };
	uint16_t targetPeriod[3][4] = { {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} };
	uint8_t chordSize[3] = { 1, 1, 1 };
	uint8_t chordLength[3] = { 1, 1, 1 };
	uint8_t chordTicks[3] = { 0, 0, 0 };
	uint8_t pitchTicks[3] = { 0, 0, 0 };
	uint8_t volumeMode[3] = { 3, 3, 3 }; // 0 = attack, 1 = decay, 2 = sustain, 3 = release
	uint8_t volumeTicks[3] = { 0, 0, 0 };
	uint8_t maxAmplitude[3] = { 127, 127, 127 };
	uint8_t attack[3] = { 0, 0, 0 };
	uint8_t decay[3] = { 0, 0, 0 };
	uint8_t sustain[3] = { 255, 255, 255 };
	uint8_t release[3] = { 0, 0, 0 };
	uint8_t pitchSlide[3] = { 0, 0, 0 };

	uint16_t startPeriodBass[4] = { 0, 0, 0, 0 };
	uint16_t targetPeriodBass[4] = { 0, 0, 0, 0 };
	uint8_t chordSizeBass = 1;
	uint8_t chordLengthBass = 1;
	uint8_t chordTicksBass = 0;
	uint8_t pitchTicksBass = 0;
	uint8_t bassRunning = 0;
	uint8_t pitchSlideBass = 0;
	uint8_t bassWaveform = 10;

	uint8_t drumTimer = 255;
	uint8_t drumType = 0; // 0 = kick, 1 = snare, 2 = closed hat, 3 = half hat, 4 = open hat, 5 = crash

	uint16_t period[3];
	uint16_t bassPeriod;
	uint8_t amplitude[3];
	uint8_t noisePeriod;
	uint8_t mixer;
};

Playhead p[2];

void combineSignals() {
	if (p[1].amplitude[0] > 0) {
		setRegister(0, p[1].period[0]);
		setRegister(1, p[1].period[0] >> 8);
		setRegister(8, p[1].amplitude[0]);
	}
	else {
		setRegister(0, p[0].period[0]);
		setRegister(1, p[0].period[0] >> 8);
		setRegister(8, p[0].amplitude[0]);
	}

	if (p[1].amplitude[1] > 0) {
		setRegister(2, p[1].period[1]);
		setRegister(3, p[1].period[1] >> 8);
		setRegister(9, p[1].amplitude[1]);
	}
	else {
		setRegister(2, p[0].period[1]);
		setRegister(3, p[0].period[1] >> 8);
		setRegister(9, p[0].amplitude[1]);
	}

	if (p[1].amplitude[2] > 0) {
		setRegister(4, p[1].period[2]);
		setRegister(5, p[1].period[2] >> 8);
		setRegister(10, p[1].amplitude[2]);
	}
	else {
		setRegister(4, p[0].period[2]);
		setRegister(5, p[0].period[2] >> 8);
		setRegister(10, p[0].amplitude[2]);
	}

	if (p[1].mixer != 0b11111000)
		setRegister(7, p[1].mixer);
	else
		setRegister(7, p[0].mixer);

	if (p[1].mixer & 0b00000100 != 0) {
		setRegister(11, p[1].bassPeriod);
		setRegister(12, p[1].bassPeriod >> 8);
		setRegister(13, p[1].bassWaveform);
	}
	else {
		setRegister(11, p[0].bassPeriod);
		setRegister(12, p[0].bassPeriod >> 8);
		setRegister(13, p[0].bassWaveform);
	}

	if (p[1].mixer & 0b00111000 != 0b00111000)
		setRegister(6, p[1].noisePeriod);
	else
		setRegister(6, p[0].noisePeriod);
}

void processSound() {
	for (int d = 0; d < 2; d++) {
		if (!p[d].playheadEnabled)
			continue;
		while (soundClockMicros[d] > (uint32_t)(p[d].tickTime) * 100) {
			soundClockMicros[d] -= (uint32_t)(p[d].tickTime) * 100;
			while (p[d].ticksToNext == 0) {
				// Process this instruction!
				// printf("%d: %d %d %d\n", d, *(p[d].instructionPointer), *(p[d].instructionPointer + 1), *(p[d].instructionPointer + 2));
				switch (*(p[d].instructionPointer + 1)) {
				case 0x00:
					p[d].playheadEnabled = false;
					break;
				case 0x01:
					p[d].tickTime = *(p[d].instructionPointer + 2);
					if (p[d].tickTime == 0)
						p[d].tickTime = 1;
					break;
				case 0x02:
					break;
				case 0x03:
					p[d].ticksToNext = 256 * (uint16_t)(*(p[d].instructionPointer + 2));
					break;
				case 0x04:
					break;
				case 0x05:
					if (p[d].patternStackSize == 0) {
						p[d].playheadEnabled = false;
						break;
					}
					p[d].patternStackSize--;
					p[d].instructionPointer = p[d].patternStack[p[d].patternStackSize];
					break;
				case 0x06:
					p[d].patternStack[p[d].patternStackSize] = p[d].instructionPointer;
					p[d].patternStackSize++;
					p[d].instructionPointer = patterns[*(p[d].instructionPointer + 2)];
					break;
				case 0x07:
					p[d].instructionPointer = patterns[*(p[d].instructionPointer + 2)];
					break;
				case 0x10:
					if (*(p[d].instructionPointer + 2) == 128) {
						p[d].volumeMode[0] = 3;
						p[d].volumeTicks[0] = 0;
					}
					else {
						p[d].startPeriod[0][0] = midiToPeriod[*(p[d].instructionPointer + 2)];
						p[d].targetPeriod[0][0] = midiToPeriod[*(p[d].instructionPointer + 2)];
						p[d].pitchTicks[0] = 0;
						p[d].volumeMode[0] = 0;
						p[d].volumeTicks[0] = 0;
						p[d].chordSize[0] = 1;
					}
					break;
				case 0x11:
					p[d].maxAmplitude[0] = *(p[d].instructionPointer + 2);
					break;
				case 0x12:
					p[d].attack[0] = *(p[d].instructionPointer + 2);
					break;
				case 0x13:
					p[d].decay[0] = *(p[d].instructionPointer + 2);
					break;
				case 0x14:
					p[d].sustain[0] = *(p[d].instructionPointer + 2);
					break;
				case 0x15:
					p[d].release[0] = *(p[d].instructionPointer + 2);
					break;
				case 0x16:
					p[d].pitchSlide[0] = *(p[d].instructionPointer + 2);
					break;
				case 0x17:
					p[d].targetPeriod[0][p[d].chordSize[0]] = midiToPeriod[*(p[d].instructionPointer + 2)];
					if (p[d].volumeMode[0] == 0 && p[d].volumeTicks[0] == 0)
						p[d].startPeriod[0][p[d].chordSize[0]] = midiToPeriod[*(p[d].instructionPointer + 2)];
					p[d].chordSize[0]++;
					break;
				case 0x18:
					p[d].chordLength[0] = *(p[d].instructionPointer + 2);
					if (p[d].chordLength[0] == 0)
						p[d].chordLength[0] = 1;
					break;
				case 0x1a:
					if (*(p[d].instructionPointer + 2) == 128) {
						p[d].volumeMode[0] = 3;
						p[d].volumeTicks[0] = 0;
					}
					else {
						if (p[d].volumeMode[0] == 3) {
							p[d].startPeriod[0][0] = midiToPeriod[*(p[d].instructionPointer + 2)];
							p[d].targetPeriod[0][0] = midiToPeriod[*(p[d].instructionPointer + 2)];
							p[d].pitchTicks[0] = 0;
							p[d].volumeMode[0] = 0;
							p[d].volumeTicks[0] = 0;
							p[d].chordSize[0] = 1;
						}
						else {
							for (int i = 0; i < 4; i++)
								p[d].startPeriod[0][i] = p[d].targetPeriod[0][i];
							p[d].targetPeriod[0][0] = midiToPeriod[*(p[d].instructionPointer + 2)];
							p[d].pitchTicks[0] = 0;
							p[d].chordSize[0] = 1;
						}
					}
					break;
				case 0x20:
					if (*(p[d].instructionPointer + 2) == 128) {
						p[d].volumeMode[1] = 3;
						p[d].volumeTicks[1] = 0;
					}
					else {
						p[d].startPeriod[1][0] = midiToPeriod[*(p[d].instructionPointer + 2)];
						p[d].targetPeriod[1][0] = midiToPeriod[*(p[d].instructionPointer + 2)];
						p[d].pitchTicks[1] = 0;
						p[d].volumeMode[1] = 0;
						p[d].volumeTicks[1] = 0;
						p[d].chordSize[1] = 1;
					}
					break;
				case 0x21:
					p[d].maxAmplitude[1] = *(p[d].instructionPointer + 2);
					break;
				case 0x22:
					p[d].attack[1] = *(p[d].instructionPointer + 2);
					break;
				case 0x23:
					p[d].decay[1] = *(p[d].instructionPointer + 2);
					break;
				case 0x24:
					p[d].sustain[1] = *(p[d].instructionPointer + 2);
					break;
				case 0x25:
					p[d].release[1] = *(p[d].instructionPointer + 2);
					break;
				case 0x26:
					p[d].pitchSlide[1] = *(p[d].instructionPointer + 2);
					break;
				case 0x27:
					p[d].targetPeriod[1][p[d].chordSize[1]] = midiToPeriod[*(p[d].instructionPointer + 2)];
					if (p[d].volumeMode[1] == 0 && p[d].volumeTicks[1] == 0)
						p[d].startPeriod[1][p[d].chordSize[1]] = midiToPeriod[*(p[d].instructionPointer + 2)];
					p[d].chordSize[1]++;
					break;
				case 0x28:
					p[d].chordLength[1] = *(p[d].instructionPointer + 2);
					if (p[d].chordLength[1] == 0)
						p[d].chordLength[1] = 1;
					break;
				case 0x2a:
					if (*(p[d].instructionPointer + 2) == 128) {
						p[d].volumeMode[1] = 3;
						p[d].volumeTicks[1] = 0;
					}
					else {
						if (p[d].volumeMode[1] == 3) {
							p[d].startPeriod[1][0] = midiToPeriod[*(p[d].instructionPointer + 2)];
							p[d].targetPeriod[1][0] = midiToPeriod[*(p[d].instructionPointer + 2)];
							p[d].pitchTicks[1] = 0;
							p[d].volumeMode[1] = 0;
							p[d].volumeTicks[1] = 0;
							p[d].chordSize[1] = 1;
						}
						else {
							for (int i = 0; i < 4; i++)
								p[d].startPeriod[1][i] = p[d].targetPeriod[1][i];
							p[d].targetPeriod[1][0] = midiToPeriod[*(p[d].instructionPointer + 2)];
							p[d].pitchTicks[1] = 0;
							p[d].chordSize[1] = 1;
						}
					}
					break;
				case 0x30:
					if (*(p[d].instructionPointer + 2) == 128) {
						p[d].volumeMode[2] = 3;
						p[d].volumeTicks[2] = 0;
					}
					else {
						p[d].startPeriod[2][0] = midiToPeriod[*(p[d].instructionPointer + 2)];
						p[d].targetPeriod[2][0] = midiToPeriod[*(p[d].instructionPointer + 2)];
						p[d].pitchTicks[2] = 0;
						p[d].volumeMode[2] = 0;
						p[d].volumeTicks[2] = 0;
						p[d].chordSize[2] = 1;
					}
					break;
				case 0x31:
					p[d].maxAmplitude[2] = *(p[d].instructionPointer + 2);
					break;
				case 0x32:
					p[d].attack[2] = *(p[d].instructionPointer + 2);
					break;
				case 0x33:
					p[d].decay[2] = *(p[d].instructionPointer + 2);
					break;
				case 0x34:
					p[d].sustain[2] = *(p[d].instructionPointer + 2);
					break;
				case 0x35:
					p[d].release[2] = *(p[d].instructionPointer + 2);
					break;
				case 0x36:
					p[d].pitchSlide[2] = *(p[d].instructionPointer + 2);
					break;
				case 0x37:
					p[d].targetPeriod[2][p[d].chordSize[2]] = midiToPeriod[*(p[d].instructionPointer + 2)];
					if (p[d].volumeMode[2] == 0 && p[d].volumeTicks[2] == 0)
						p[d].startPeriod[2][p[d].chordSize[2]] = midiToPeriod[*(p[d].instructionPointer + 2)];
					p[d].chordSize[2]++;
					break;
				case 0x38:
					p[d].chordLength[2] = *(p[d].instructionPointer + 2);
					if (p[d].chordLength[2] == 0)
						p[d].chordLength[2] = 1;
					break;
				case 0x3a:
					if (*(p[d].instructionPointer + 2) == 128) {
						p[d].volumeMode[2] = 3;
						p[d].volumeTicks[2] = 0;
					}
					else {
						if (p[d].volumeMode[2] == 3) {
							p[d].startPeriod[2][0] = midiToPeriod[*(p[d].instructionPointer + 2)];
							p[d].targetPeriod[2][0] = midiToPeriod[*(p[d].instructionPointer + 2)];
							p[d].pitchTicks[2] = 0;
							p[d].volumeMode[2] = 0;
							p[d].volumeTicks[2] = 0;
							p[d].chordSize[2] = 1;
						}
						else {
							for (int i = 0; i < 4; i++)
								p[d].startPeriod[2][i] = p[d].targetPeriod[2][i];
							p[d].targetPeriod[2][0] = midiToPeriod[*(p[d].instructionPointer + 2)];
							p[d].pitchTicks[2] = 0;
							p[d].chordSize[2] = 1;
						}
					}
					break;
				case 0x40:
					if (*(p[d].instructionPointer + 2) == 128) {
						p[d].bassRunning = 0;
					}
					else {
						p[d].startPeriodBass[0] = midiToPeriod[*(p[d].instructionPointer + 2) + 60];
						p[d].targetPeriodBass[0] = midiToPeriod[*(p[d].instructionPointer + 2) + 60];
						p[d].bassRunning = 1;
						p[d].pitchTicksBass = 0;
						p[d].chordSizeBass = 1;
					}
					break;
				case 0x46:
					p[d].pitchSlideBass = *(p[d].instructionPointer + 2);
					break;
				case 0x47:
					p[d].targetPeriodBass[p[d].chordSizeBass] = midiToPeriod[*(p[d].instructionPointer + 2) + 60];
					if (p[d].pitchTicksBass == 0 && p[d].startPeriodBass[0] == p[d].targetPeriodBass[0])
						p[d].startPeriodBass[p[d].chordSizeBass] = midiToPeriod[*(p[d].instructionPointer + 2) + 60];
					p[d].chordSizeBass++;
					break;
				case 0x48:
					p[d].chordLengthBass = *(p[d].instructionPointer + 2);
					if (p[d].chordLengthBass == 0)
						p[d].chordLengthBass = 1;
					break;
				case 0x49:
					if (*(p[d].instructionPointer + 2))
						p[d].bassWaveform = 12;
					else
						p[d].bassWaveform = 10;
				case 0x4a:
					if (*(p[d].instructionPointer + 2) == 128) {
						p[d].bassRunning = 0;
					}
					else {
						if (!p[d].bassRunning) {
							p[d].startPeriodBass[0] = midiToPeriod[*(p[d].instructionPointer + 2) + 60];
							p[d].targetPeriodBass[0] = midiToPeriod[*(p[d].instructionPointer + 2) + 60];
							p[d].bassRunning = 1;
							p[d].pitchTicksBass = 0;
							p[d].chordSizeBass = 1;
						}
						else {
							for (int i = 0; i < 4; i++)
								p[d].startPeriodBass[i] = p[d].targetPeriodBass[i];
							p[d].targetPeriodBass[0] = midiToPeriod[*(p[d].instructionPointer + 2) + 60];
							p[d].pitchTicksBass = 0;
							p[d].chordSizeBass = 1;
						}
					}
					break;
				case 0x50:
					p[d].drumType = *(p[d].instructionPointer + 2);
					p[d].drumTimer = 0;
				}
				p[d].instructionPointer += 3;
				p[d].ticksToNext += *p[d].instructionPointer;
				if (!p[d].playheadEnabled)
					break;
			}
			p[d].ticksToNext--;
			if (p[d].playheadEnabled) {
				for (int i = 0; i < 3; i++) {
					// Which note in the chord is this?
					uint8_t chordIndex;
					if (p[d].chordTicks[i] >= p[d].chordLength[i] * p[d].chordSize[i])
						p[d].chordTicks[i] = 0;
					chordIndex = p[d].chordTicks[i] / p[d].chordLength[i];
					p[d].chordTicks[i]++;

					// What's the pitch of the oscillator?
					uint16_t period;
					if (p[d].pitchSlide[i] == 0)
						period = p[d].targetPeriod[i][chordIndex];
					else
						period = (p[d].startPeriod[i][chordIndex] * (p[d].pitchSlide[i] - p[d].pitchTicks[i]) + p[d].targetPeriod[i][chordIndex] * p[d].pitchTicks[i]) / p[d].pitchSlide[i];
					if (p[d].pitchTicks[i] < p[d].pitchSlide[i])
						p[d].pitchTicks[i]++;
					p[d].period[i] = period;
					// What's the volume?
					uint8_t volume;
					switch (p[d].volumeMode[i]) {
					case 0:
						if (p[d].attack[i] == 0)
							volume = p[d].maxAmplitude[i];
						else
							volume = (uint16_t)p[d].maxAmplitude[i] * p[d].volumeTicks[i] / p[d].attack[i];
						if (p[d].volumeTicks[i] < p[d].attack[i])
							p[d].volumeTicks[i]++;
						if (p[d].volumeTicks[i] >= p[d].attack[i]) {
							p[d].volumeTicks[i] = 0;
							p[d].volumeMode[i] = 1;
						}
						break;
					case 1:
						if (p[d].decay[i] == 0)
							volume = (uint16_t)p[d].maxAmplitude[i] * p[d].sustain[i] / 255;
						else
							volume = ((uint16_t)p[d].maxAmplitude[i] * (p[d].decay[i] - p[d].volumeTicks[i]) + ((uint16_t)p[d].maxAmplitude[i] * p[d].sustain[i] / 255) * p[d].volumeTicks[i]) / p[d].decay[i];
						if (p[d].volumeTicks[i] < p[d].decay[i])
							p[d].volumeTicks[i]++;
						if (p[d].volumeTicks[i] >= p[d].decay[i]) {
							p[d].volumeTicks[i] = 0;
							p[d].volumeMode[i] = 2;
						}
						break;
					case 2:
						volume = (uint16_t)p[d].maxAmplitude[i] * p[d].sustain[i] / 255;
						p[d].volumeTicks[i] = 0;
						break;
					default:
						if (p[d].release[i] == 0)
							volume = 0;
						else
							volume = ((uint16_t)p[d].maxAmplitude[i] * p[d].sustain[i] / 255) * (p[d].release[i] - p[d].volumeTicks[i]) / p[d].release[i];
						if (p[d].volumeTicks[i] < p[d].release[i])
							p[d].volumeTicks[i]++;
						break;
					}

					p[d].amplitude[i] = volume >> 4;
				}

				// Do all that stuff for bass!
				// Which note in the chord is this?
				uint8_t chordIndex;
				if (p[d].chordTicksBass >= p[d].chordLengthBass * p[d].chordSizeBass)
					p[d].chordTicksBass = 0;
				chordIndex = p[d].chordTicksBass / p[d].chordLengthBass;
				p[d].chordTicksBass++;

				// What's the pitch of the oscillator?
				uint16_t period;
				if (p[d].pitchSlideBass == 0)
					period = p[d].targetPeriodBass[chordIndex];
				else
					period = (p[d].startPeriodBass[chordIndex] * (p[d].pitchSlideBass - p[d].pitchTicksBass) + p[d].targetPeriodBass[chordIndex] * p[d].pitchTicksBass) / p[d].pitchSlideBass;
				if (p[d].pitchTicksBass < p[d].pitchSlideBass)
					p[d].pitchTicksBass++;
				p[d].bassPeriod = period;

				if (p[d].bassRunning) {
					p[d].amplitude[2] = 16;
				}

				if (p[d].bassRunning)
					p[d].mixer = 0b11111100;
				else
					p[d].mixer = 0b11111000;

				// Drums?
				if (p[d].drumTimer < 255) {
					switch (p[d].drumType) {
					case 0:
						if (p[d].drumTimer == 0) {
							p[d].mixer = 0b11111000;
							p[d].period[2] = 1024;
							p[d].amplitude[2] = 15;
						}
						else if (p[d].drumTimer == 1) {
							p[d].mixer = 0b11111000;
							p[d].period[2] = 1536;
							p[d].amplitude[2] = 15;
						}
						else if (p[d].drumTimer == 2) {
							p[d].mixer = 0b11111000;
							p[d].period[2] = 2048;
							p[d].amplitude[2] = 15;
						}
						else if (p[d].drumTimer == 3) {
							p[d].mixer = 0b11111000;
							p[d].period[2] = 2560;
							p[d].amplitude[2] = 15;
						}
						break;
					case 1:
						if (p[d].drumTimer < 4) {
							p[d].mixer = 0b11011100;
							p[d].noisePeriod = 31;
							p[d].amplitude[2] = 15 - p[d].drumTimer * 4;
						}
						break;
					case 2:
						if (p[d].drumTimer < 2) {
							p[d].mixer = 0b11011100;
							p[d].noisePeriod = 3;
							p[d].amplitude[2] = 15 - p[d].drumTimer * 8;
						}
						break;
					case 3:
						if (p[d].drumTimer < 8) {
							p[d].mixer = 0b11011100;
							p[d].noisePeriod = 3;
							p[d].amplitude[2] = 15 - p[d].drumTimer * 2;
						}
						break;
					case 4:
						if (p[d].drumTimer < 128) {
							p[d].mixer = 0b11011100;
							p[d].noisePeriod = 3;
							p[d].amplitude[2] = 15 - p[d].drumTimer / 8;
						}
						break;
					case 5:
						if (p[d].drumTimer < 128) {
							p[d].mixer = 0b11011100;
							p[d].noisePeriod = 15;
							p[d].amplitude[2] = 15 - p[d].drumTimer / 8;
						}
						break;
					}

					p[d].drumTimer++;
				}

			}
			else {
				p[d].mixer = 0b11111000;
				p[d].amplitude[0] = 0;
				p[d].amplitude[1] = 0;
				p[d].amplitude[2] = 0;
			}

			combineSignals();
		}
	}
}


void setup();
void loop();

int main(int argc, char* argv[]) {
	SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO);

	SDL_AudioSpec want, have;
	SDL_AudioDeviceID dev;

	SDL_memset(&want, 0, sizeof(want)); /* or SDL_zero(want) */
	want.freq = SAMPLE_RATE;
	want.format = AUDIO_F32;
	want.channels = 1;
	want.samples = BUFFER_LENGTH;
	want.callback = computeAudio; /* you wrote this function elsewhere -- see SDL_AudioSpec for details */

	window = SDL_CreateWindow("Myrmidon Simulator v1.0", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 768, 512, SDL_WINDOW_OPENGL);

	if (window == NULL)
		return 1;

	SDL_memset(&want, 0, sizeof(want)); /* or SDL_zero(want) */
	want.freq = SAMPLE_RATE;
	want.format = AUDIO_F32;
	want.channels = 1;
	want.samples = BUFFER_LENGTH;
	want.callback = computeAudio; /* you wrote this function elsewhere -- see SDL_AudioSpec for details */

	dev = SDL_OpenAudioDevice(NULL, 0, &want, &have, SDL_AUDIO_ALLOW_FORMAT_CHANGE);
	if (dev == 0) {
		SDL_Log("Failed to open audio: %s", SDL_GetError());
	}
	else {
		if (have.format != want.format) { /* we let this one thing change. */
			SDL_Log("We didn't get Float32 audio format.");
		}

		SDL_PauseAudioDevice(dev, 0); /* start audio playing. */
	}

	setup();
	while (true) {
		loop();
	}

	SDL_CloseAudioDevice(dev);
	SDL_DestroyWindow(window);
	SDL_Quit();
	return 0;
}

// N.B. For the simulator to work properly, CLOCKS_PER_SEC MUST be >= 1000!
int millis() {
    clock_t t = clock();
    uint64_t milliseconds;
    milliseconds = (uint64_t)(t) * 1000;
    milliseconds /= CLOCKS_PER_SEC;
    return (int)(milliseconds);
}

// Taken from StackOverflow, thanks Kornel Kisielewicz
template< typename T >
std::string int_to_hex(T i)
{
    std::stringstream stream;
    stream << std::hex << (uint64_t)(i);
    return stream.str();
}

void readPage(uint16_t page_index, uint16_t page_address) {
    if (page_address >= 8192 || (page_address & 0x07ff) != 0)
        return;
    std::string indexStr = int_to_hex(page_index);
    while (indexStr.length() < 4)
        indexStr = "0" + indexStr;
    std::string fname = indexStr + "R.bin";
    FILE* file;
    errno_t err;
    if ((err = fopen_s(&file, fname.c_str(), "rb")) == 0) {
        fread((uint8_t*)memory + 2 * page_address, 1, 4096, file);
        fclose(file);
    }
    else {
        fname = indexStr + "W.bin";
        if (fopen_s(&file, fname.c_str(), "rb") == 0) {
            fread((uint8_t*)memory + 2 * page_address, 1, 4096, file);
            fclose(file);
        }
    }
}

void writePage(uint16_t page_index, uint16_t page_address) {
    if (page_address >= 8192 || (page_address & 0x07ff) != 0)
        return;
    std::string indexStr = int_to_hex(page_index);
    while (indexStr.length() < 4)
        indexStr = "0" + indexStr;
    std::string fname = indexStr + "W.bin";
    FILE* file;
    if (fopen_s(&file, fname.c_str(), "wb") == 0) {
        fseek(file, 0, SEEK_SET);
        fwrite((uint8_t*)memory + 2 * page_address, 1, 4096, file);
        fclose(file);
    }
}

bool sdCardValid = true;

void setup() {
    for (int16_t y = 0; y < 64; y++) {
        for (int16_t x = 0; x < 96; x++) {
            framebuffer[y][x] = 0;
            if (x < 48)
                flagbuffer[y][x] = 0;
            background[y][x] = 0;
            spritesheets[x % 2][y][x / 2] = 0;
        }
    }

    for (int16_t i = 0; i < 8192; i++) {
        memory[i] = 0;
    }
    for (int16_t i = 0; i < 256; i++) {
        routines[i] = 0;
    }
    for (int16_t i = 0; i < 32; i++) {
        stack[i] = 0;
    }

    for (int16_t i = 0; i < 256; i++) {
        palette[i] = 0;
    }
    palette_offset = 0;

    test_flags = 0;

    memcpy((byte*)(memory)+4096, startup, 4096);
	memcpy((byte*)(memory)+4096*3, splashMusic, 4096);

    memcpy(background, logo, 6144);

    memory[1] = 1;
    memory[2] = 0xffff;
    window_pointer = 0x0080;
    instruction_pointer = 0x0800;

    for (int16_t i = 0; i < 8; i++) {
        input_state[i] = 0;
        input_state_prev[i] = 0;
    }

    input_poll_time = millis();

    printf("INIT SUCCESS\n");
}

inline uint16_t getR(uint8_t reg) {
    if (reg < 0x80)
        return memory[reg];
    else
        return memory[(uint16_t)(reg - 0x80) + window_pointer];
}

inline void setR(uint8_t reg, uint16_t value) {
    uint16_t address;
    if (reg < 0x80)
        address = reg;
    else
        address = (uint16_t)(reg - 0x80) + window_pointer;
    if (address <= 0x0002)
        return;
    memory[address] = value;
}

void loop(void) {
    // Poll input if necessary
    if (millis() >= input_poll_time) {
        input_poll_time = millis() + 25;
        for (int16_t i = 0; i < 8; i++) {
            input_state_prev[i] = input_state[i];
        }

        SDL_PumpEvents();
        const uint8_t* state = SDL_GetKeyboardState(NULL);
        input_state[0] = state[SDL_SCANCODE_W];
        input_state[1] = state[SDL_SCANCODE_S];
        input_state[2] = state[SDL_SCANCODE_A];
        input_state[3] = state[SDL_SCANCODE_D];
        input_state[4] = state[SDL_SCANCODE_K];
        input_state[5] = state[SDL_SCANCODE_L];
        input_state[6] = state[SDL_SCANCODE_J];
        input_state[7] = state[SDL_SCANCODE_I];
    }

    // Read the four bytes at IP
    uint16_t inst1, inst2;
    inst1 = memory[instruction_pointer];
    inst2 = memory[instruction_pointer + 1];
    // Determine opcode and register indices
    uint8_t opcode, registerX, registerY, registerZ;
    opcode = inst1;
    registerX = inst1 >> 8;
    registerY = inst2;
    registerZ = inst2 >> 8;

    /*{
        std::string valStr;
        valStr = int_to_hex(instruction_pointer);
        printf("%s", valStr.c_str());
        printf(": ");
        valStr = int_to_hex(opcode);
        printf("%s", valStr.c_str());
        printf(" ");
        valStr = int_to_hex(registerX);
        printf("%s", valStr.c_str());
        printf(" ");
        valStr = int_to_hex(registerY);
        printf("%s", valStr.c_str());
        printf(" ");
        valStr = int_to_hex(registerZ);
        printf("%s", valStr.c_str());
        printf(" \n");
      }*/

    bool had_jumped = has_jumped;
    has_jumped = false;

    switch (opcode) {
    case 0x00:
        // nop
        break;
    case 0x01:
        // end
        instruction_pointer += 2 * inst2;
        has_jumped = inst2 != 0;
        break;
    case 0x02:
        // if
        if (getR(registerX) == 0) {
            instruction_pointer += 2 * inst2;
            has_jumped = inst2 != 0;
        }
        break;
    case 0x03:
        // while
        /*{
          String valStr;
          valStr = String(instruction_pointer, HEX);
          Serial.print(valStr.c_str());
          Serial.print(": ");
          if (getR(registerX) == 0) {
            Serial.println("PASS");
          }
          else {
            Serial.println("LOOP");
          }
          delay(100);
        }*/
        if (getR(registerX) == 0) {
            instruction_pointer += 2 * inst2;
            has_jumped = inst2 != 0;
        }
        break;
    case 0x04:
        // else
        if (!had_jumped) {
            instruction_pointer += 2 * inst2;
            has_jumped = inst2 != 0;
        }
        break;
    case 0x05:
        // switch
    {
        uint16_t val = getR(registerX);
        instruction_pointer += 2 * val;
        has_jumped = val != 0;
    }
    break;
    case 0x06:
        // gz
        if (getR(registerX) == 0) {
            instruction_pointer += 2 * inst2;
            has_jumped = inst2 != 0;
        }
        break;
    case 0x07:
        // gnz
        if (getR(registerX) != 0) {
            instruction_pointer += 2 * inst2;
            has_jumped = inst2 != 0;
        }
        break;
    case 0x08:
        // def
        routines[registerX] = instruction_pointer + 2;
        instruction_pointer += 2 * inst2;
        has_jumped = inst2 != 0;
        break;
    case 0x09:
        // call
        stack[stack_size] = instruction_pointer + 2;
        stack_size++;
        instruction_pointer = routines[registerX];
        has_jumped = true;
        break;
    case 0x0a:
        // goto
        instruction_pointer = inst2;
        has_jumped = true;
        break;
    case 0x0b:
        // break
        instruction_pointer += 2 * inst2;
        has_jumped = inst2 != 0;
        break;
    case 0x0c:
        // continue
        instruction_pointer += 2 * inst2;
        has_jumped = inst2 != 0;
        break;
    case 0x0d:
        // return
        stack_size--;
        instruction_pointer = stack[stack_size];
        has_jumped = true;
        break;
    case 0x0e:
        // reset
        SDL_DestroyWindow(window);
        SDL_Quit();
        std::exit(0); // Can't really restart the system, now, can we?
        break;
    case 0x0f:
        // DEBUG OPCODE
    {
        uint16_t val = getR(registerX);
        std::string valStr = std::to_string(val);
        printf("%s\n", valStr.c_str());
    }
    break;
    case 0x10:
        // +
    {
        uint16_t valY = getR(registerY);
        uint16_t valZ = getR(registerZ);
        setR(registerX, valY + valZ);
    }
    break;
    case 0x11:
        // -
    {
        uint16_t valY = getR(registerY);
        uint16_t valZ = getR(registerZ);
        setR(registerX, valY - valZ);
    }
    break;
    case 0x12:
        // *
    {
        uint16_t valY = getR(registerY);
        uint16_t valZ = getR(registerZ);
        setR(registerX, valY * valZ);
    }
    break;
    case 0x13:
        // /
    {
        uint16_t valY = getR(registerY);
        uint16_t valZ = getR(registerZ);
        setR(registerX, valY / valZ);
    }
    break;
    case 0x14:
        // s/
    {
        uint16_t valY = getR(registerY);
        uint16_t valZ = getR(registerZ);
        setR(registerX, (uint16_t)(((int16_t)valY) / ((int16_t)valZ)));
    }
    break;
    case 0x15:
        // %
    {
        uint16_t valY = getR(registerY);
        uint16_t valZ = getR(registerZ);
        setR(registerX, valY % valZ);
    }
    break;
    case 0x16:
        // s%
    {
        uint16_t valY = getR(registerY);
        uint16_t valZ = getR(registerZ);
        setR(registerX, (uint16_t)(((int16_t)valY) % ((int16_t)valZ)));
    }
    break;
    case 0x17:
        // frac
    {
        uint16_t valY = getR(registerY);
        uint16_t valZ = getR(registerZ);
        setR(registerX, (uint16_t)((((uint32_t)valY) << 16) / valZ));
    }
    break;
    case 0x18:
        // sfrac
    {
        uint16_t valY = getR(registerY);
        uint16_t valZ = getR(registerZ);
        setR(registerX, (uint16_t)((((int32_t)valY) << 16) / ((int16_t)valZ)));
        // TODO: CHECK -- NOT SURE IF THIS IS CORRECT?
    }
    break;
    case 0x19:
        // ==
    {
        uint16_t valY = getR(registerY);
        uint16_t valZ = getR(registerZ);
        setR(registerX, valY == valZ);
    }
    break;
    case 0x1a:
        // !=
    {
        uint16_t valY = getR(registerY);
        uint16_t valZ = getR(registerZ);
        setR(registerX, valY != valZ);
    }
    break;
    case 0x1b:
        // <
    {
        uint16_t valY = getR(registerY);
        uint16_t valZ = getR(registerZ);
        setR(registerX, valY < valZ);
    }
    break;
    case 0x1c:
        // s<
    {
        uint16_t valY = getR(registerY);
        uint16_t valZ = getR(registerZ);
        setR(registerX, ((int16_t)valY) < ((int16_t)valZ));
    }
    break;
    case 0x1d:
        // <=
    {
        uint16_t valY = getR(registerY);
        uint16_t valZ = getR(registerZ);
        setR(registerX, valY <= valZ);
    }
    break;
    case 0x1e:
        // s<=
    {
        uint16_t valY = getR(registerY);
        uint16_t valZ = getR(registerZ);
        setR(registerX, ((int16_t)valY) <= ((int16_t)valZ));
    }
    break;
    case 0x1f:
        // &
    {
        uint16_t valY = getR(registerY);
        uint16_t valZ = getR(registerZ);
        setR(registerX, valY & valZ);
    }
    break;
    case 0x20:
        // &&
    {
        uint16_t valY = getR(registerY);
        uint16_t valZ = getR(registerZ);
        setR(registerX, valY && valZ);
    }
    break;
    case 0x21:
        // |
    {
        uint16_t valY = getR(registerY);
        uint16_t valZ = getR(registerZ);
        setR(registerX, valY | valZ);
    }
    break;
    case 0x22:
        // ^
    {
        uint16_t valY = getR(registerY);
        uint16_t valZ = getR(registerZ);
        setR(registerX, valY ^ valZ);
    }
    break;
    case 0x23:
        // <<
    {
        uint16_t valY = getR(registerY);
        uint16_t valZ = getR(registerZ);
        setR(registerX, valY << valZ);
    }
    break;
    case 0x24:
        // >>
    {
        uint16_t valY = getR(registerY);
        uint16_t valZ = getR(registerZ);
        setR(registerX, valY >> valZ);
    }
    break;
    case 0x25:
        // ?
    {
        uint16_t valY = getR(registerY);
        uint16_t valZ = getR(registerZ);
        if (valY == 0)
            setR(registerX, valZ);
    }
    break;
    case 0x26:
        // absgn
    {
        uint16_t valZ = getR(registerZ);
        if (valZ > 0) {
            setR(registerX, valZ);
            setR(registerY, 1);
        }
        else if (valZ < 0) {
            setR(registerX, -valZ);
            setR(registerY, -1);
        }
        else {
            setR(registerX, 0);
            setR(registerY, 0);
        }
    }
    break;
    case 0x27:
        // sqrt
    {
        uint16_t valZ = getR(registerZ);
        float answer = sqrt(valZ);
        uint32_t ans2 = (uint32_t)(answer * 65536);
        setR(registerX, (uint16_t)(ans2 >> 16));
        setR(registerY, (uint16_t)ans2);
    }
    break;
    case 0x28:
        // red
    {
        uint16_t valY = getR(registerY);
        uint16_t valZ = getR(registerZ);
        setR(registerX, ((valZ & 0xf8) << 8) | (valY & 0x07ff));
    }
    break;
    case 0x29:
        // green
    {
        uint16_t valY = getR(registerY);
        uint16_t valZ = getR(registerZ);
        setR(registerX, ((valZ & 0xfc) << 3) | (valY & 0xf81f));
    }
    break;
    case 0x2a:
        // blue
    {
        uint16_t valY = getR(registerY);
        uint16_t valZ = getR(registerZ);
        setR(registerX, ((valZ & 0xf8) >> 3) | (valY & 0xffe0));
    }
    break;
    case 0x2b:
        // +c
    {
        uint16_t valY = getR(registerY);
        uint16_t valZ = getR(registerZ);
        setR(registerX, ((uint32_t)(valY)+(uint32_t)(valZ)) >> 16);
    }
    break;
    case 0x2c:
        // -c
    {
        uint16_t valY = getR(registerY);
        uint16_t valZ = getR(registerZ);
        setR(registerX, ((uint32_t)(valY)-(uint32_t)(valZ)) >> 16);
    }
    break;
    case 0x2d:
        // *c
    {
        uint16_t valY = getR(registerY);
        uint16_t valZ = getR(registerZ);
        setR(registerX, ((uint32_t)(valY) * (uint32_t)(valZ)) >> 16);
    }
    break;
    case 0x2e:
        // conc
    {
        uint16_t valY = getR(registerY);
        uint16_t valZ = getR(registerZ);
        setR(registerX, (valY << 8) | (valZ & 0xff));
    }
    break;
    case 0x2f:
        // high
    {
        uint16_t valY = getR(registerY);
        setR(registerX, valY >> 8);
    }
    break;
    case 0x30:
        // =
        setR(registerX, getR(registerY));
        break;
    case 0x31:
        // =
        setR(registerX, inst2);
        break;
    case 0x32:
        // load
        setR(registerX, memory[getR(registerY)]);
        break;
    case 0x33:
        // load
        setR(registerX, memory[inst2]);
        break;
    case 0x34:
        // store
    {
        uint16_t addr = getR(registerY);
        if (addr > 2 && addr < 8192)
            memory[addr] = getR(registerX);
    }
    break;
    case 0x35:
        // store
    {
        uint16_t addr = inst2;
        if (addr > 2 && addr < 8192)
            memory[addr] = getR(registerX);
    }
    break;
    case 0x36:
        // window
    {
        uint16_t addr = getR(registerY);
        if (addr < 8192 - 128)
            window_pointer = addr;
    }
    break;
    case 0x37:
        // window
    {
        uint16_t addr = inst2;
        if (addr < 8192 - 128)
            window_pointer = addr;
    }
    break;
    case 0x38:
        // skip
    {
        uint16_t addr = getR(registerY);
        if (addr < 8192) {
            stack_size = 0;
            instruction_pointer = addr - 2;
            has_jumped = true;
        }
    }
    break;
    case 0x39:
        // skip
    {
        uint16_t addr = inst2;
        if (addr < 8192) {
            stack_size = 0;
            instruction_pointer = addr - 2;
            has_jumped = true;
        }
    }
    break;
    case 0x3a:
        // skim
    {
        uint16_t addr = getR(registerY);
        uint16_t maxaddr = (addr & 0xf800) + 2048;
        if (maxaddr > 8192)
            maxaddr = 8192;
        for (uint16_t ptr = addr & 0xfffe; ptr < maxaddr; ptr += 2) {
            if ((memory[ptr] & 0xff) == 0x08)
                routines[memory[ptr] >> 8] = ptr + 2;
        }
    }
    break;
    case 0x3b:
        // skim
    {
        uint16_t addr = inst2;
        uint16_t maxaddr = (addr & 0xf800) + 2048;
        if (maxaddr > 8192)
            maxaddr = 8192;
        for (uint16_t ptr = addr & 0xfffe; ptr < maxaddr; ptr += 2) {
            if ((memory[ptr] & 0xff) == 0x08)
                routines[memory[ptr] >> 8] = ptr + 2;
        }
    }
    break;
    case 0x40:
        // read
        readPage(getR(registerX), getR(registerY));
        SDL_Delay(100); // Hey, this is a *simulator* after all
        break;
    case 0x41:
        // read
        readPage(getR(registerX), inst2);
        SDL_Delay(100); // Hey, this is a *simulator* after all
        break;
    case 0x42:
        // write
        writePage(getR(registerX), getR(registerY));
        SDL_Delay(100); // Hey, this is a *simulator* after all
        break;
    case 0x43:
        // write
        writePage(getR(registerX), inst2);
        SDL_Delay(100); // Hey, this is a *simulator* after all
        break;
    case 0x44:
        // readb
    {
        std::string indexStr = int_to_hex(getR(registerX));
        while (indexStr.length() < 4)
            indexStr = "0" + indexStr;
        std::string fname = "B" + indexStr + ".bin";
        FILE* file;
        if (fopen_s(&file, fname.c_str(), "rb") == 0) {
            fread((uint8_t*)background, 1, 6144, file);
            fclose(file);
        }
        SDL_Delay(100); // Hey, this is a *simulator* after all
    }
    break;
    case 0x45:
        // reads
    {
        uint16_t ry = getR(registerY);
        if (ry > 1)
            break;
        std::string indexStr = int_to_hex(getR(registerX));
        while (indexStr.length() < 4)
            indexStr = "0" + indexStr;
        std::string fname = "S" + indexStr + ".bin";
        FILE* file;
        if (fopen_s(&file, fname.c_str(), "rb") == 0) {
            fread((uint8_t*)spritesheets + 3072 * ry, 1, 3072, file);
            fclose(file);
        }
        SDL_Delay(100); // Hey, this is a *simulator* after all
    }
    break;
    case 0x46:
        // readp
    {
        std::string indexStr = int_to_hex(getR(registerX));
        while (indexStr.length() < 4)
            indexStr = "0" + indexStr;
        std::string fname = "P" + indexStr + ".bin";
        FILE* file;
        if (fopen_s(&file, fname.c_str(), "rb") == 0) {
            fread((uint8_t*)palette, 1, 1024, file);
            fclose(file);
        }
        SDL_Delay(100); // Hey, this is a *simulator* after all
    }
    break;
    case 0x47:
        // rex
	{
		if (sdCardValid) {
			uint16_t current_page = instruction_pointer & 0xf800;
			readPage(getR(registerX), current_page);
			instruction_pointer = current_page - 2;
			stack_size = 0;
			has_jumped = true;
			p[0].playheadEnabled = false;
			p[1].playheadEnabled = false;
		}
		else {
			memcpy(background, sd_error, 6144);
			for (int y = 0; y < 64; y++) {
				for (int x = 0; x < 96; x++) {
					framebuffer[y][x] = (uint8_t)(background[y][x] + palette_offset);
				}
			}
			uint8_t intermediateBuffer[64][96][3];
			for (int y = 0; y < 64; y++) {
				for (int x = 0; x < 96; x++) {
					float red, green, blue;
					uint16_t color = palette[framebuffer[y][x]];
					red = (float)(color >> 11) / 31.0f;
					green = (float)((color >> 5) & 0x3f) / 63.0f;
					blue = (float)(color & 0x1f) / 31.0f;
					red = powf(red, 0.5f);
					green = powf(green, 0.5f);
					blue = powf(blue, 0.5f);
					intermediateBuffer[y][x][0] = (uint8_t)(red * 255.0f);
					intermediateBuffer[y][x][1] = (uint8_t)(green * 255.0f);
					intermediateBuffer[y][x][2] = (uint8_t)(blue * 255.0f);
				}
			}

			SDL_Surface* screen = SDL_GetWindowSurface(window);
			SDL_Surface* surface = SDL_CreateRGBSurfaceWithFormatFrom((void*)intermediateBuffer, 96, 64, 24, 288, SDL_PIXELFORMAT_RGB24);
			SDL_BlitScaled(surface, NULL, screen, NULL);
			SDL_FreeSurface(surface);
			SDL_UpdateWindowSurface(window);
			SDL_Delay(5); // Needed for timing functions to work correctly
		}
	}
    break;
    case 0x50:
        // refresh
    {
        // I wish I could just blit the surface as 565, but I need to do some gamma correction to get faithful color reproduction
        uint8_t intermediateBuffer[64][96][3];
        for (int y = 0; y < 64; y++) {
            for (int x = 0; x < 96; x++) {
                float red, green, blue;
				uint16_t color = palette[framebuffer[y][x]];
                red = (float)(color >> 11) / 31.0f;
                green = (float)((color >> 5) & 0x3f) / 63.0f;
                blue = (float)(color & 0x1f) / 31.0f;
                red = powf(red, 0.5f);
                green = powf(green, 0.5f);
                blue = powf(blue, 0.5f);
                intermediateBuffer[y][x][0] = (uint8_t)(red * 255.0f);
                intermediateBuffer[y][x][1] = (uint8_t)(green * 255.0f);
                intermediateBuffer[y][x][2] = (uint8_t)(blue * 255.0f);
            }
        }

        SDL_Surface* screen = SDL_GetWindowSurface(window);
        SDL_Surface* surface = SDL_CreateRGBSurfaceWithFormatFrom((void*)intermediateBuffer, 96, 64, 24, 288, SDL_PIXELFORMAT_RGB24);
        SDL_BlitScaled(surface, NULL, screen, NULL);
        SDL_FreeSurface(surface);
        SDL_UpdateWindowSurface(window);
        SDL_Delay(5); // Needed for timing functions to work correctly
        break;
    }
    case 0x51:
        // clear
    {
        uint8_t color = getR(registerX);
        for (int16_t y = 0; y < 64; y++) {
            for (int16_t x = 0; x < 96; x++) {
                framebuffer[y][x] = color;
                if (x < 48)
                    flagbuffer[y][x] = 0;
            }
        }
    }
    break;
    case 0x52:
        // dbg
    {
        uint16_t valX = getR(registerX);
        uint8_t rowX = (uint8_t)(valX);
        uint8_t colX = (uint8_t)(valX >> 8);
        for (int16_t y = 0; y < 64; y++) {
            for (int16_t x = 0; x < 96; x++) {
                int16_t y2 = y + rowX;
                if (y2 < 0)
                    y2 += 64;
                y2 = y2 % 64;
                int16_t x2 = x + colX;
                if (x2 < 0)
                    x2 += 96;
                x2 = x2 % 96;
                uint32_t color = palette[(uint8_t)(background[y2][x2] + palette_offset)];
                if ((x & 1) == 0)
                    flagbuffer[y][x >> 1] |= (uint8_t)((color & 0x00f00000) >> 16);
                else
                    flagbuffer[y][x >> 1] |= (uint8_t)((color & 0x00f00000) >> 20);
                if ((color & 0x00010000) == 0)
                    framebuffer[y][x] = (uint8_t)(background[y2][x2] + palette_offset);
            }
        }
    }
    break;
    case 0x53:
        // dbg16
    {
        uint16_t valX = getR(registerX);
        uint16_t valY = getR(registerY);
        int8_t rowX = (int8_t)(valX);
        int8_t colX = (int8_t)(valX >> 8);
        int8_t rowY = (int8_t)(valY);
        int8_t colY = (int8_t)(valY >> 8);
        for (int16_t r = 0; r < 16; r++) {
            for (int16_t c = 0; c < 16; c++) {
                if (rowY + r < 0)
                    continue;
                if (rowY + r >= 64)
                    continue;
                if (colY + c < 0)
                    continue;
                if (colY + c >= 96)
                    continue;
                uint32_t color = palette[(uint8_t)(background[r + rowX][c + colX] + palette_offset)];
                if (((colY + c) & 1) == 0)
                    flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 16);
                else
                    flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 20);
                if ((color & 0x00010000) == 0)
                    framebuffer[rowY + r][colY + c] = (uint8_t)(background[r + rowX][c + colX] + palette_offset);
            }
        }
    }
    break;
    case 0x54:
        // dbg8
    {
        uint16_t valX = getR(registerX);
        uint16_t valY = getR(registerY);
        int8_t rowX = (int8_t)(valX);
        int8_t colX = (int8_t)(valX >> 8);
        int8_t rowY = (int8_t)(valY);
        int8_t colY = (int8_t)(valY >> 8);
        for (int16_t r = 0; r < 8; r++) {
            for (int16_t c = 0; c < 8; c++) {
                if (rowY + r < 0)
                    continue;
                if (rowY + r >= 64)
                    continue;
                if (colY + c < 0)
                    continue;
                if (colY + c >= 96)
                    continue;
                uint32_t color = palette[(uint8_t)(background[r + rowX][c + colX] + palette_offset)];
                if (((colY + c) & 1) == 0)
                    flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 16);
                else
                    flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 20);
                if ((color & 0x00010000) == 0)
                    framebuffer[rowY + r][colY + c] = (uint8_t)(background[r + rowX][c + colX] + palette_offset);
            }
        }
    }
    break;
    case 0x55:
        // dbg4
    {
        uint16_t valX = getR(registerX);
        uint16_t valY = getR(registerY);
        int8_t rowX = (int8_t)(valX);
        int8_t colX = (int8_t)(valX >> 8);
        int8_t rowY = (int8_t)(valY);
        int8_t colY = (int8_t)(valY >> 8);
        for (int16_t r = 0; r < 4; r++) {
            for (int16_t c = 0; c < 4; c++) {
                if (rowY + r < 0)
                    continue;
                if (rowY + r >= 64)
                    continue;
                if (colY + c < 0)
                    continue;
                if (colY + c >= 96)
                    continue;
                uint32_t color = palette[(uint8_t)(background[r + rowX][c + colX] + palette_offset)];
                if (((colY + c) & 1) == 0)
                    flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 16);
                else
                    flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 20);
                if ((color & 0x00010000) == 0)
                    framebuffer[rowY + r][colY + c] = (uint8_t)(background[r + rowX][c + colX] + palette_offset);
            }
        }
    }
    break;
    case 0x56:
        // dbg
    {
        uint16_t valX = getR(registerX);
        uint16_t valY = getR(registerY);
        uint16_t valZ = getR(registerZ);
        int8_t rowX = (int8_t)(valX);
        int8_t colX = (int8_t)(valX >> 8);
        int8_t rowY = (int8_t)(valY);
        int8_t colY = (int8_t)(valY >> 8);
        uint8_t widZ = (uint8_t)(valZ);
        uint8_t heiZ = (uint8_t)(valZ >> 8);
        for (int16_t r = 0; r < heiZ; r++) {
            for (int16_t c = 0; c < widZ; c++) {
                if (rowY + r < 0)
                    continue;
                if (rowY + r >= 64)
                    continue;
                if (colY + c < 0)
                    continue;
                if (colY + c >= 96)
                    continue;
                uint32_t color = palette[(uint8_t)(background[r + rowX][c + colX] + palette_offset)];
                if (((colY + c) & 1) == 0)
                    flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 16);
                else
                    flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 20);
                if ((color & 0x00010000) == 0)
                    framebuffer[rowY + r][colY + c] = (uint8_t)(background[r + rowX][c + colX] + palette_offset);
            }
        }
    }
    break;
    case 0x57:
        // dss
    {
        uint16_t valX = getR(registerX);
        int8_t rowX = (int8_t)(valX);
        int8_t colX = (int8_t)(valX >> 8);
        for (int16_t r = 0; r < 64; r++) {
            for (int16_t c = 0; c < 96; c++) {
                uint8_t indices = spritesheets[(r + rowX) >> 6][(r + rowX) & 0x3f][(c + colX) >> 1];
                uint8_t index = indices & 0xf;
                if (((c + colX) & 1) == 0)
                    index = indices >> 4;
                uint32_t color = palette[(uint8_t)(index + palette_offset)];
                if ((c & 1) == 0)
                    flagbuffer[r][c >> 1] |= (uint8_t)((color & 0x00f00000) >> 16);
                else
                    flagbuffer[r][c >> 1] |= (uint8_t)((color & 0x00f00000) >> 20);
                if ((color & 0x00010000) == 0)
                    framebuffer[r][c] = (uint8_t)(index + palette_offset);
            }
        }
    }
    break;
    case 0x58:
        // dss16
    {
        uint16_t valX = getR(registerX);
        uint16_t valY = getR(registerY);
        int8_t rowX = (int8_t)(valX);
        int8_t colX = (int8_t)(valX >> 8);
        int8_t rowY = (int8_t)(valY);
        int8_t colY = (int8_t)(valY >> 8);
        for (int16_t r = 0; r < 16; r++) {
            for (int16_t c = 0; c < 16; c++) {
                if (rowY + r < 0)
                    continue;
                if (rowY + r >= 64)
                    continue;
                if (colY + c < 0)
                    continue;
                if (colY + c >= 96)
                    continue;
                uint8_t indices = spritesheets[(r + rowX) >> 6][(r + rowX) & 0x3f][(c + colX) >> 1];
                uint8_t index = indices & 0xf;
                if (((c + colX) & 1) == 0)
                    index = indices >> 4;
                uint32_t color = palette[(uint8_t)(index + palette_offset)];
                if (((colY + c) & 1) == 0)
                    flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 16);
                else
                    flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 20);
                if ((color & 0x00010000) == 0)
                    framebuffer[rowY + r][colY + c] = (uint8_t)(index + palette_offset);
            }
        }
    }
    break;
    case 0x59:
        // dss8
    {
        uint16_t valX = getR(registerX);
        uint16_t valY = getR(registerY);
        int8_t rowX = (int8_t)(valX);
        int8_t colX = (int8_t)(valX >> 8);
        int8_t rowY = (int8_t)(valY);
        int8_t colY = (int8_t)(valY >> 8);
        for (int16_t r = 0; r < 8; r++) {
            for (int16_t c = 0; c < 8; c++) {
                if (rowY + r < 0)
                    continue;
                if (rowY + r >= 64)
                    continue;
                if (colY + c < 0)
                    continue;
                if (colY + c >= 96)
                    continue;
                uint8_t indices = spritesheets[(r + rowX) >> 6][(r + rowX) & 0x3f][(c + colX) >> 1];
                uint8_t index = indices & 0xf;
                if (((c + colX) & 1) == 0)
                    index = indices >> 4;
                uint32_t color = palette[(uint8_t)(index + palette_offset)];
                if (((colY + c) & 1) == 0)
                    flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 16);
                else
                    flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 20);
                if ((color & 0x00010000) == 0)
                    framebuffer[rowY + r][colY + c] = (uint8_t)(index + palette_offset);
            }
        }
    }
    break;
    case 0x5a:
        // dss4
    {
        uint16_t valX = getR(registerX);
        uint16_t valY = getR(registerY);
        int8_t rowX = (int8_t)(valX);
        int8_t colX = (int8_t)(valX >> 8);
        int8_t rowY = (int8_t)(valY);
        int8_t colY = (int8_t)(valY >> 8);
        for (int16_t r = 0; r < 4; r++) {
            for (int16_t c = 0; c < 4; c++) {
                if (rowY + r < 0)
                    continue;
                if (rowY + r >= 64)
                    continue;
                if (colY + c < 0)
                    continue;
                if (colY + c >= 96)
                    continue;
                uint8_t indices = spritesheets[(r + rowX) >> 6][(r + rowX) & 0x3f][(c + colX) >> 1];
                uint8_t index = indices & 0xf;
                if (((c + colX) & 1) == 0)
                    index = indices >> 4;
                uint32_t color = palette[(uint8_t)(index + palette_offset)];
                if (((colY + c) & 1) == 0)
                    flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 16);
                else
                    flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 20);
                if ((color & 0x00010000) == 0)
                    framebuffer[rowY + r][colY + c] = (uint8_t)(index + palette_offset);
            }
        }
    }
    break;
    case 0x5b:
        // dss
    {
        uint16_t valX = getR(registerX);
        uint16_t valY = getR(registerY);
        uint16_t valZ = getR(registerZ);
        int8_t rowX = (int8_t)(valX);
        int8_t colX = (int8_t)(valX >> 8);
        int8_t rowY = (int8_t)(valY);
        int8_t colY = (int8_t)(valY >> 8);
        uint8_t widZ = (uint8_t)(valZ);
        uint8_t heiZ = (uint8_t)(valZ >> 8);
        for (int16_t r = 0; r < heiZ; r++) {
            for (int16_t c = 0; c < widZ; c++) {
                if (rowY + r < 0)
                    continue;
                if (rowY + r >= 64)
                    continue;
                if (colY + c < 0)
                    continue;
                if (colY + c >= 96)
                    continue;
                uint8_t indices = spritesheets[(r + rowX) >> 6][(r + rowX) & 0x3f][(c + colX) >> 1];
                uint8_t index = indices & 0xf;
                if (((c + colX) & 1) == 0)
                    index = indices >> 4;
                uint32_t color = palette[(uint8_t)(index + palette_offset)];
                if (((colY + c) & 1) == 0)
                    flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 16);
                else
                    flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 20);
                if ((color & 0x00010000) == 0)
                    framebuffer[rowY + r][colY + c] = (uint8_t)(index + palette_offset);
            }
        }
    }
    break;
    case 0x5c:
        // dpx
    {
        uint16_t valX = getR(registerX);
        uint8_t valY = getR(registerY);
        int8_t rowX = (int8_t)(valX);
        int8_t colX = (int8_t)(valX >> 8);
        if (rowX < 0)
            break;
        if (rowX >= 64)
            break;
        if (colX < 0)
            break;
        if (colX >= 96)
            break;
        framebuffer[rowX][colX] = valY;
    }
    break;
    case 0x5d:
        // dchar
    {
        uint16_t valX = getR(registerX);
        uint16_t valY = getR(registerY);
        uint16_t valZ = getR(registerZ);
        int8_t rowX = (int8_t)((valX << 6) + (valZ >> 4) * 8);
        int8_t colX = (int8_t)((valZ & 0xf) * 6);
        int8_t rowY = (uint8_t)(valY);
        int8_t colY = (int8_t)(valY >> 8);
        for (int16_t r = 0; r < 8; r++) {
            for (int16_t c = 0; c < 6; c++) {
                if (rowY + r < 0)
                    continue;
                if (rowY + r >= 64)
                    continue;
                if (colY + c < 0)
                    continue;
                if (colY + c >= 96)
                    continue;
                uint8_t indices = spritesheets[(r + rowX) >> 6][(r + rowX) & 0x3f][(c + colX) >> 1];
                uint8_t index = indices & 0xf;
                if (((c + colX) & 1) == 0)
                    index = indices >> 4;
                uint32_t color = palette[(uint8_t)(index + palette_offset)];
                if (((colY + c) & 1) == 0)
                    flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 16);
                else
                    flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 20);
                if ((color & 0x00010000) == 0)
                    framebuffer[rowY + r][colY + c] = (uint8_t)(index + palette_offset);
            }
        }
    }
    break;
    case 0x5e:
        // dstr
    {
        uint16_t valX = getR(registerX);
        uint16_t valY = getR(registerY);
        uint16_t valZ = getR(registerZ);
        int8_t rowY = (int8_t)(valY);
        int8_t colY = (int8_t)(valY >> 8);
        uint16_t pointer = valZ * 2;
        while (true) {
            uint8_t charInd = *((uint8_t*)(memory)+pointer);
            if (charInd == 0)
                break;
            if (charInd == 13) {
                colY -= 96;
                while (colY >= 96)
                    colY += 6;
                pointer++;
                continue;
            }
            if (charInd == 10) {
                colY -= 96;
                while (colY >= 96)
                    colY += 6;
                rowY += 8;
                pointer++;
                continue;
            }
            if (charInd == 127) {
                pointer++;
                continue;
            }
            int8_t rowX = (int8_t)((valX << 6) + (charInd >> 4) * 8);
            int8_t colX = (int8_t)((charInd & 0xf) * 6);
            for (int16_t r = 0; r < 8; r++) {
                for (int16_t c = 0; c < 6; c++) {
                    if (rowY + r < 0)
                        continue;
                    if (rowY + r >= 64)
                        continue;
                    if (colY + c < 0)
                        continue;
                    if (colY + c >= 96)
                        continue;
                    uint8_t indices = spritesheets[(r + rowX) >> 6][(r + rowX) & 0x3f][(c + colX) >> 1];
                    uint8_t index = indices & 0xf;
                    if (((c + colX) & 1) == 0)
                        index = indices >> 4;
                    uint32_t color = palette[(uint8_t)(index + palette_offset)];
                    if (((colY + c) & 1) == 0)
                        flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 16);
                    else
                        flagbuffer[rowY + r][(colY + c) >> 1] |= (uint8_t)((color & 0x00f00000) >> 20);
                    if ((color & 0x00010000) == 0)
                        framebuffer[rowY + r][colY + c] = (uint8_t)(index + palette_offset);
                }
            }

            pointer++;
            colY += 6;
            if (colY > 90) {
                colY -= 96;
                if (colY >= 96)
                    colY += 6;
                rowY += 8;
            }
        }
    }
    break;
    case 0x60:
        // clearp
    {
        uint32_t color = (uint32_t)(getR(registerY)) | ((uint32_t)(getR(registerZ)) << 16);
        for (int16_t i = 0; i < 256; i++) {
            palette[i] = color;
        }
    }
    break;
    case 0x61:
        // setp
    {
        uint32_t color = (uint32_t)(getR(registerY)) | ((uint32_t)(getR(registerZ)) << 16);
        uint8_t i = getR(registerX);
        palette[i] = color;
    }
    break;
    case 0x62:
        // getp
    {
        uint8_t i = getR(registerX);
        uint32_t color = palette[i];
        setR(registerY, (uint16_t)color);
        setR(registerZ, (uint16_t)(color >> 16));
    }
    break;
    case 0x63:
        // setpoffs
        palette_offset = (uint8_t)(getR(registerY));
        break;
    case 0x64:
        // setpoffs
        palette_offset = (uint8_t)(inst2);
        break;
    case 0x70:
        // frame
        {
            uint16_t rate = getR(registerX);
            if (rate == 0)
                rate = 33; // Backwards compatibility
            while (true) {
                uint32_t m = millis();
                if ((m % 100) % rate == 0)
                    break;
                /*if (m % 100 == 0 || m % 100 == 33 || m % 100 == 67)
                  break;*/
            }
        }
        break;
    case 0x71:
        // delay
    {
        uint16_t ms = getR(registerY);
        SDL_Delay(ms);
    }
    break;
    case 0x72:
        // delay
    {
        uint16_t ms = inst2;
        SDL_Delay(ms);
    }
    break;
    case 0x80:
        // button
    {
        uint16_t val = getR(registerY);
        if (val > 7)
            break;
        setR(registerX, input_state[val]);
    }
    break;
    case 0x81:
        // button
    {
        uint16_t val = inst2;
        if (val > 7)
            break;
        setR(registerX, input_state[val]);
    }
    break;
    case 0x82:
        // buttonp
    {
        uint16_t val = getR(registerY);
        if (val > 7)
            break;
        setR(registerX, input_state[val] && !input_state_prev[val]);
    }
    break;
    case 0x83:
        // buttonp
    {
        uint16_t val = inst2;
        if (val > 7)
            break;
        setR(registerX, input_state[val] && !input_state_prev[val]);
    }
    break;
    case 0x84:
        // buttonr
    {
        uint16_t val = getR(registerY);
        if (val > 7)
            break;
        setR(registerX, !input_state[val] && input_state_prev[val]);
    }
    break;
    case 0x85:
        // buttonr
    {
        uint16_t val = inst2;
        if (val > 7)
            break;
        setR(registerX, !input_state[val] && input_state_prev[val]);
    }
    break;
    case 0x90:
        // colflags
        test_flags = getR(registerY) & 0xf;
        break;
    case 0x91:
        // colflags
        test_flags = inst2 & 0xf;
        break;
    case 0x92:
        // col
    {
        bool done = 0;
        for (int16_t y = 0; y < 64; y++) {
            for (int16_t x = 0; x < 96; x++) {
                uint8_t flags;
                if ((x & 1) == 1)
                    flags = flagbuffer[y][x >> 1] & 0xf;
                else
                    flags = flagbuffer[y][x >> 1] >> 4;
                if ((flags & test_flags) == test_flags) {
                    done = 1;
                    break;
                }
            }
            if (done)
                break;
        }
        setR(registerX, done);
    }
    break;
    case 0x93:
        // col16
    {
        bool done = 0;
        uint16_t valY = getR(registerY);
        int8_t rowY = (int8_t)(valY);
        int8_t colY = (int8_t)(valY >> 8);
        for (int16_t r = 0; r < 16; r++) {
            for (int16_t c = 0; c < 16; c++) {
                if (rowY + r < 0)
                    continue;
                if (rowY + r >= 64)
                    continue;
                if (colY + c < 0)
                    continue;
                if (colY + c >= 96)
                    continue;
                uint8_t flags;
                if (((colY + c) & 1) == 1)
                    flags = flagbuffer[rowY + r][(colY + c) >> 1] & 0xf;
                else
                    flags = flagbuffer[rowY + r][(colY + c) >> 1] >> 4;
                if ((flags & test_flags) == test_flags) {
                    done = 1;
                    break;
                }
            }
            if (done)
                break;
        }
        setR(registerX, done);
    }
    break;
    case 0x94:
        // col8
    {
        bool done = 0;
        uint16_t valY = getR(registerY);
        int8_t rowY = (int8_t)(valY);
        int8_t colY = (int8_t)(valY >> 8);
        for (int16_t r = 0; r < 8; r++) {
            for (int16_t c = 0; c < 8; c++) {
                if (rowY + r < 0)
                    continue;
                if (rowY + r >= 64)
                    continue;
                if (colY + c < 0)
                    continue;
                if (colY + c >= 96)
                    continue;
                uint8_t flags;
                if (((colY + c) & 1) == 1)
                    flags = flagbuffer[rowY + r][(colY + c) >> 1] & 0xf;
                else
                    flags = flagbuffer[rowY + r][(colY + c) >> 1] >> 4;
                if ((flags & test_flags) == test_flags) {
                    done = 1;
                    break;
                }
            }
            if (done)
                break;
        }
        setR(registerX, done);
    }
    break;
    case 0x95:
        // col4
    {
        bool done = 0;
        uint16_t valY = getR(registerY);
        int8_t rowY = (int8_t)(valY);
        int8_t colY = (int8_t)(valY >> 8);
        for (int16_t r = 0; r < 4; r++) {
            for (int16_t c = 0; c < 4; c++) {
                if (rowY + r < 0)
                    continue;
                if (rowY + r >= 64)
                    continue;
                if (colY + c < 0)
                    continue;
                if (colY + c >= 96)
                    continue;
                uint8_t flags;
                if (((colY + c) & 1) == 1)
                    flags = flagbuffer[rowY + r][(colY + c) >> 1] & 0xf;
                else
                    flags = flagbuffer[rowY + r][(colY + c) >> 1] >> 4;
                if ((flags & test_flags) == test_flags) {
                    done = 1;
                    break;
                }
            }
            if (done)
                break;
        }
        setR(registerX, done);
    }
    break;
    case 0x96:
        // col
    {
        bool done = 0;
        uint16_t valY = getR(registerY);
        uint16_t valZ = getR(registerZ);
        int8_t rowY = (int8_t)(valY);
        int8_t colY = (int8_t)(valY >> 8);
        uint8_t widZ = (uint8_t)(valZ);
        uint8_t heiZ = (uint8_t)(valZ >> 8);
        for (int16_t r = 0; r < heiZ; r++) {
            for (int16_t c = 0; c < widZ; c++) {
                if (rowY + r < 0)
                    continue;
                if (rowY + r >= 64)
                    continue;
                if (colY + c < 0)
                    continue;
                if (colY + c >= 96)
                    continue;
                uint8_t flags;
                if (((colY + c) & 1) == 1)
                    flags = flagbuffer[rowY + r][(colY + c) >> 1] & 0xf;
                else
                    flags = flagbuffer[rowY + r][(colY + c) >> 1] >> 4;
                if ((flags & test_flags) == test_flags) {
                    done = 1;
                    break;
                }
            }
            if (done)
                break;
        }
        setR(registerX, done);
    }
    break;
    case 0xa0:
        // itoa
    {
        uint16_t addr = getR(registerY);
        std::string str = std::to_string((uint16_t)getR(registerX));
        memcpy((void*)(&memory[addr]), (void*)(str.c_str()), 8);
    }
    break;
    case 0xa1:
        // itoa
    {
        uint16_t addr = inst2;
        std::string str = std::to_string((uint16_t)getR(registerX));
        memcpy((void*)(&memory[addr]), (void*)(str.c_str()), 8);
    }
    break;
    case 0xa2:
        // sitoa
    {
        uint16_t addr = getR(registerY);
        std::string str = std::to_string((int16_t)getR(registerX));
        memcpy((void*)(&memory[addr]), (void*)(str.c_str()), 8);
    }
    break;
    case 0xa3:
        // sitoa
    {
        uint16_t addr = inst2;
        std::string str = std::to_string((int16_t)getR(registerX));
        memcpy((void*)(&memory[addr]), (void*)(str.c_str()), 8);
    }
    break;
    case 0xa4:
        // strw
    {

        uint16_t pointer = getR(registerY) * 2;
        uint16_t w = 0;
        uint16_t maxW = 0;
        while (true) {
            uint8_t charInd = *((uint8_t*)(memory)+pointer);
            if (charInd == 0)
                break;
            if (charInd == 13) {
                w = 0;
                pointer++;
                continue;
            }
            if (charInd == 10) {
                w = 0;
                pointer++;
                continue;
            }
            if (charInd == 127) {
                pointer++;
                continue;
            }
            w += 6;
            if (w > maxW)
                maxW = w;
            pointer++;
        }
        setR(registerX, maxW);
    }
    break;
    case 0xa5:
        // strh
    {

        uint16_t pointer = getR(registerY) * 2;
        uint16_t h = 8;
        while (true) {
            uint8_t charInd = *((uint8_t*)(memory)+pointer);
            if (charInd == 0)
                break;
            if (charInd == 13) {
                h += 8;
                pointer++;
                continue;
            }
            if (charInd == 10) {
                h += 8;
                pointer++;
                continue;
            }
            if (charInd == 127) {
                pointer++;
                continue;
            }
            pointer++;
        }
        setR(registerX, h);
    }
    break;
	case 0xb0:
		// loadsnd
	{
		uint16_t addr = getR(registerY);
		uint16_t maxaddr = (addr & 0xf800) + 2048;
		uint8_t *start_address = (uint8_t*)(&memory[addr]);
		uint8_t *end_address = (uint8_t*)(&memory[maxaddr]);
		for (uint8_t *i = start_address; i + 2 < end_address; i += 3) {
			if (*(i + 1) == 0x04) {
				patterns[*(i + 2)] = i;
			}
		}
	}
	break;
	case 0xb1:
		// loadsnd
	{
		uint16_t addr = inst2;
		uint16_t maxaddr = (addr & 0xf800) + 2048;
		uint8_t *start_address = (uint8_t*)(&memory[addr]);
		uint8_t *end_address = (uint8_t*)(&memory[maxaddr]);
		for (uint8_t *i = start_address; i + 2 < end_address; i += 3) {
			if (*(i + 1) == 0x04) {
				patterns[*(i + 2)] = i;
			}
		}
	}
	break;
	case 0xb2:
		// playsnd
	{
		uint8_t d = registerX & 1;
		uint8_t pattern = getR(registerY);
		p[d].instructionPointer = patterns[pattern];

		p[d].playheadEnabled = true;
		p[d].ticksToNext = 0;
		p[d].patternStackSize = 0;

		soundClockMicros[d] = 0.0;

		for (int i = 0; i < 3; i++) {
			for (int j = 0; j < 4; j++) {
				p[d].startPeriod[i][j] = 0;
				p[d].targetPeriod[i][j] = 0;
			}

			p[d].chordSize[i] = 1;
			p[d].chordLength[i] = 1;
			p[d].chordTicks[i] = 0;
			p[d].pitchTicks[i] = 0;
			p[d].volumeMode[i] = 3;
			p[d].volumeTicks[i] = 0;
		}

		for (int j = 0; j < 4; j++) {
			p[d].startPeriodBass[j] = 0;
			p[d].targetPeriodBass[j] = 0;
		}

		p[d].chordSizeBass = 1;
		p[d].chordLengthBass = 1;
		p[d].chordTicksBass = 0;
		p[d].pitchTicksBass = 0;
		p[d].bassRunning = 0;

		p[d].drumTimer = 255;
		p[d].drumType = 0;
	}
	break;
	case 0xb3:
		// playsnd
	{
		uint8_t d = registerX & 1;
		uint8_t pattern = inst2;
		p[d].instructionPointer = patterns[pattern];

		p[d].playheadEnabled = true;
		p[d].ticksToNext = 0;
		p[d].patternStackSize = 0;

		soundClockMicros[d] = 0.0;

		for (int i = 0; i < 3; i++) {
			for (int j = 0; j < 4; j++) {
				p[d].startPeriod[i][j] = 0;
				p[d].targetPeriod[i][j] = 0;
			}

			p[d].chordSize[i] = 1;
			p[d].chordLength[i] = 1;
			p[d].chordTicks[i] = 0;
			p[d].pitchTicks[i] = 0;
			p[d].volumeMode[i] = 3;
			p[d].volumeTicks[i] = 0;
		}

		for (int j = 0; j < 4; j++) {
			p[d].startPeriodBass[j] = 0;
			p[d].targetPeriodBass[j] = 0;
		}

		p[d].chordSizeBass = 1;
		p[d].chordLengthBass = 1;
		p[d].chordTicksBass = 0;
		p[d].pitchTicksBass = 0;
		p[d].bassRunning = 0;

		p[d].drumTimer = 255;
		p[d].drumType = 0;
	}
	break;
	case 0xb4:
		// stopsnd
	{
		uint8_t d = registerX & 1;
		p[d].playheadEnabled = false;

		setRegister(8, 0);
		setRegister(9, 0);
		setRegister(10, 0);
	}
	break;
    case 0xf0:
        // random
    {
        uint16_t val = getR(registerY);
        setR(registerX, rand() % val);
    }
    break;
    case 0xf1:
        // random
    {
        uint16_t val = inst2;
        setR(registerX, rand() % val);
    }
    break;
    }

    instruction_pointer += 2;
}